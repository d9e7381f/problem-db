INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('概率计算', '　　生成n个∈[a,b]的随机整数，输出它们的和为x的概率。', '　　一行输入四个整数依次为n，a，b，x，用空格分隔。', '　　输出一行包含一个小数位和为x的概率，小数点后保留四位小数', '[{"input": "2 1 3 4", "output": "0.3333"}]', '8675627469283636acbb2aa1f022ac23', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='概率计算' limit 1),(select id from problem_tag where name='动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('日期计算', '　　已知2011年11月11日是星期五，问YYYY年MM月DD日是星期几？注意考虑闰年的情况。尤其是逢百年不闰，逢400年闰的情况。', '　　输入只有一行
　　YYYY MM DD', '　　输出只有一行
　　W', '[]', '9f32e131c2fab1163ad085d82974c559', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('9-2 文本加密', '　　先编写函数EncryptChar,按照下述规则将给定的字符c转化（加密）为新的字符："A"转化"B"，"B"转化为"C"，... ..."Z"转化为"a"，"a"转化为"b",... ..., "z"转化为"A"，其它字符不加密。编写程序，加密给定字符串。', '', '', '[]', '958aae2211852f6c76ef0df6b11d28df', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('新建Microsoft Word', '　　L正在出题，新建了一个word文档，想不好取什么名字，身旁一人惊问：“你出的题目叫《新建Microsoft Word文档》吗？”，L大喜，一拍桌子，说：“好，就叫这个名字了。”
　　仔细观察，当你新建一个word文档时，会得到一个名为“新建 Microsoft Word 文档.doc”的文件，再新建一个，则名为“新建 Microsoft Word 文档(2).doc”，再新建，便是“新建 Microsoft Word 文档(3).doc”。不断新建，编号不断递增。倘若你现在新建了三个文档，然后删除了“新建 Microsoft Word 文档(2).doc”，再新建就又会得到一个“新建 Microsoft Word 文档(2).doc”。

　　严格说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。

　　请编程模拟以上过程，支持以下两种操作
　　New：新建一个word文档，反馈新建的文档的编号
　　Delete id：删除一个编号为id的word文档，反馈删除是否成功
　　初始时一个文件都没有，“新建 Microsoft Word 文档.doc”的编号算作1。', '　　第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为”Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。', '　　对于输入的每一行，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。', '[{"input": "12\nNew\nNew\nNew\nDelete 2\nNew\nDelete 4\nDelete 3\nDelete 1\nNew\nNew\nNew\nDelete 4", "output": "1\n2\n3\nSuccessful\n2\nFailed\nSuccessful\nSuccessful\n1\n3\n4\nSuccessful"}]', 'b2b1c1ac82bb1124fa6f120ef1666fa4', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Crystal clear', '　　一个高新技术公司研制了一种绝缘的新材料，这种材料由晶体和晶体赖以生长的网格矩形组成，网格上生长点的间隔距离为1cm。晶体就是由这些生长点为向外生长，直到生长出直径为1cm的一个圆。
　　应用这种新材料需要将网格切割成块。在切割中存在一个问题，在切割过程中一些晶体可能被破坏。当晶体圆片被切割，并且切割不过圆片的中心时，晶体的绝缘性能被破坏（切割线与晶体圆片相切时，仍不破坏晶体的绝缘性能）。

　　于是，一个材料块的有效容量就是其包含的未被破坏的晶体（或晶体的一部分）的总面积。下图给出了一个实例，阴影部分是未被破坏的晶体。

　　你的任务就是测量统计一个给定材料块的有效容量。
　　注意：任何不经过圆心的割线都会使被割的圆完全失效。', '　　输入包括一组多边形的顶点序列。每一个描述多边形的数据包括一个正整数N，表示顶点总数。以下有N行，每行两个整数x和y，表示一个顶点。所有顶点按照顺时针排列，并且坐标的绝对值不超过250。当N=0时表示输入结束。', '　　对于每一个有效的多边形，输出其有效容量，精确到小数点后3位。', '[{"input": "5\n0 2\n3 5\n6 3\n6 0\n1 0\n0", "output": "15.315"}]', '5d3e3651bc1e3986d687780a149e6068', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);INSERT INTO problem_tag(name) VALUES('计算几何');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Crystal clear' limit 1),(select id from problem_tag where name='计算几何' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('道路和航路', '
农夫约翰正在针对一个新区域的牛奶配送合同进行研究。他打算分发牛奶到T个城镇（标号为1..T），这些城镇通过R条标号为（1..R）的道路和P条标号为（1..P）的航路相连。
每一条公路i或者航路i表示成连接城镇Ai（1<=A_i<=T）和Bi（1<=Bi<=T）代价为Ci。每一条公路，Ci的范围为0<=Ci<=10,000；由于奇怪的运营策略，每一条航路的Ci可能为负的，也就是-10,000<=Ci<=10,000。
每一条公路都是双向的，正向和反向的花费是一样的，都是非负的。
每一条航路都根据输入的Ai和Bi进行从Ai->Bi的单向通行。实际上，如果现在有一条航路是从Ai到Bi的话，那么意味着肯定没有通行方案从Bi回到Ai。
农夫约翰想把他那优良的牛奶从配送中心送到各个城镇，当然希望代价越小越好，你可以帮助他嘛？配送中心位于城镇S中（1<=S<=T）。
', '
输入的第一行包含四个用空格隔开的整数T，R，P，S。
接下来R行，描述公路信息，每行包含三个整数，分别表示Ai，Bi和Ci。
接下来P行，描述航路信息，每行包含三个整数，分别表示Ai，Bi和Ci。
', '
	输出T行，分别表示从城镇S到每个城市的最小花费，如果到不了的话输出NO PATH。
', '[{"input": "\n6 3 3 4\n1 2 5\n3 4 5\n5 6 10\n3 5 -100\n4 6 -100\n1 3 -10\n", "output": "\nNO PATH\nNO PATH\n5\n0\n-95\n-100\n\t"}]', 'c92e4bc2126e9a896cc93b4a1eb06941', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 4);INSERT INTO problem_tag(name) VALUES('最短路');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='道路和航路' limit 1),(select id from problem_tag where name='最短路' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('三个整数的排序', '　　﻿输入三个数，比较其大小，并从大到小输出。', '　　一行三个整数。', '　　一行三个整数，从大到小排序。', '[{"input": "33 88 77", "output": "88 77 33"}]', '7d09910b52a53b31f333bbe9542c4d1a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('简单排序');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='三个整数的排序' limit 1),(select id from problem_tag where name='简单排序' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Barcodes', '　　Code-11是一种主要用来将标签编码为条形码的编码方式。被编码的字符被限制为0-9和 - 号，以及一种特殊的符号：开始和结束标志（开始标志出现在Code-11编码的最前面而结束标志出现在最后面）。
　　Code-11的编码会独立的编码每一个字符。一个字符会由5个相邻的区域来编码。每个区域可能是深色和浅色中的一种，相邻的两个区域的颜色一定不同，每次编码的第一个区域的颜色一定是深色的。每个区域的宽度也不是一定的，我们将宽度总共分为两种，用0表示一个窄的区域，用1表示一个宽的区域。
字符编码000001110001201001311000400101510100601100700011810010910000-00100开始/结束标志00110
　　因此，字符1被编码后就会表示成为深色的宽区域，浅色的窄区域，深色的窄区域，浅色的窄区域，深色的宽区域这五个区域。并且，在编码后两个相邻的字符各自编码出来的五个区域之间需要用一个浅色的窄区域将它们隔开。这个浅色的窄区域的唯一功能就是分割两个字符编码出来的区域。
　　Code-11这种编码方式可以简化我们的编码和解码过程，因为他仅需要区分窄区域和宽区域，并且提高了对低打印水平的容忍度。
　　为了能够检验编码中出现的错误，Code-11在编码时会用到两个检验字符C和K，并且会把C和K插入到原串的末尾再进行编码（在结束标志之前）。假设需要被编码的串有n个字符，分别是c1、c2……cn，那么检验字符C的值就应该是sigma( ( ( n - i ) mod 10 + 1 ) * w ( c [i] ) ) mod 11(1<=i<=n)。其中，w(c[i])是字符c[i]的权重。如果c[i]是0、1、2、……9这些字符，那么c[i]的权重就是0、1、2、……9。如果c[i]是 - ，那么c[i]的权重就是10。（注意mod的运算优先级比+高）
　　与此对应的检验字符K的值是sigma( ( ( n - i + 1) mod 9 +1 ) * w ( c [i] ) ) mod 11(1<=i<=n+1)，其中c[n+1]即为检验字符C。举个例子，假设需要被编码的字符串是123-45，那么我们有C=5和K=2，所以最终需要被编码的字符串是123-4552，并且有一个开始标志和结束标志分别在头部和尾部。
　　一般的简单的条形码读取器会包含数百个小型的CCD传感器，这些CCD传感器会识别出深色和浅色区域以及每一块的宽度。利用这些信息，解码器就会将解码得到被编码之前的信息。由于条形码的方向不是固定的，所以无论读取器是正着扫描的条形码还是倒着扫描的，解码器都需要能够解码。
　　你的任务是解码一个被Code-11编码过的条形码。你能够知道每一块区域的宽度，并且宽的区域的宽度是窄的区域的宽度的两倍。但是由于打印设备的不完美，所以读取的区域宽度可能跟实际的宽度有5%的误差。在数据当中不会有编码前长度为0的字符串。', '　　第一行一个正整数N，代表被编码后的条形码的区域个数。
　　接下来N个正整数，每行最多十个正整数，代表条形码每个区域的宽度。', '　　如果该条形码无法被成功解码，输出"bad code"。
　　如果该条形码能被成功解码但是检验字符C的值不正确，输出"bad C"。
　　如果该条形码能被成功解码且检验字符C的值正确但检验字符K的值不正确，输出"bad K"。
　　如果该条形码能被成功解码且两个检验字符均是正确的，输出不包含检验字符和起始结束标志的原字符串。', '[{"input": "59\n10 20 20 10 10 10 20 10 10 20\n10 10 10 10 20 10 20 10 10 10\n20 10 20 10 20 10 20 10 10 10\n10 10 20 10 10 10 10 10 10 20\n20 10 20 10 10 20 10 10 20 10\n10 10 20 10 10 20 20 10 10", "output": "123-45"}]', '476a6606c0c02461bc1ff4685cd8962e', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Barcodes' limit 1),(select id from problem_tag where name='模拟' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Workshops', '　　第一次加利福尼亚整体会议在1979年于旧金山举行。“加利福尼亚的”是一个轻微的夸大，因为23个参加者实际上都住在旧金山。几年后，在1987年，会议是真正的“加利福尼亚的”了，337个参加者从该州的各个地方来。自从那时起，参加者的数目像芯片尺寸那样增长。在1993年，会议被重新命名为“美国整体会议”（有2549个参加者），第二次重新命名（被重新命名为“世界整体会议”）是在1997年之后，当时参加者的数量增加到9973人。在对词语“银河”是否有排除银河外的生命形式的意味这一问题的一些讨论后，会议在2003年得到了它现在的名字（银河整体会议）。第二年，所有注册了的参加者仍然是地球上的，虽然一些参加者积极地汇报，说已经感觉到有地球外的生命出席。
　　专题讨论会的数量随着参加者的数量的增长而增长。对于即将开始的会议，组织方必须面对一些务实但是非常讨厌的时间安排的问题。对于2005年的这次会议而言，寄宿地点决定同时提供的专题讨论会不能超过1000个。然而他们必须租他们能够拿到的每个大厅或者教室。这些房间中的某一些只在一个受限制的时间段是可以用的。
　　在第一天的上午，公开会议在一个足球馆内举行。到了下午，参加者出席专题讨论会。然后，组织方的工作人员有一个所有专题讨论会的列表，和每个房间能够容纳的人数，并且每个具体房间可以使用的时间一定是清楚的。有了这些信息，工作人员必须将每个专题讨论会安排到一个在可容纳人数和时间上都足够的房间中。因为这个问题不一定能够解决，足球馆内提供了帐篷，供不能容纳到房间中的人使用。这些帐篷可以容纳足够多的人，但是它们有令人不愉快的热量和噪声。因此组织方的工作人员希望时间表能够最小化需要安排到帐篷中的专题讨论会的数量（即不能安排到房间中的专题讨论会的数量）。如果有多种答案能够最小化需要安排到帐篷中的专题讨论会的数量，工作人员希望最小化需要参加帐篷中的专题讨论会的参加者的数量。', '　　输入文件包含多组测试数据。每个测试数据由两部分组成：专题讨论会的列表和租到的房间的列表。
　　专题讨论会列表以一行（包含一个整数w(0<w<=1000)，表示专题讨论会的数量）。
　　接下来的w行，每行2个整数，描述一个专题讨论会。第一个数p表示参加者的人数(0<p<=100)。第二个数d表示专题讨论会持续的时间(0<d<=300)，以分钟计。为了你的方便，专题讨论会其他的细节被省略。所有的专题讨论会在14:00开始。
　　租到的房间的列表以一行（包含一个整数r(0<r<=1000)，表示租到的房间的数量）。
　　接下来的r行，每行1个整数s和一个形如hh:mm的字符串，描述一个租到的房间。整数s表示房间可以容纳的人数(0<p<=100)。形如hh:mm的字符串表示房间必须腾空的时间，以24小时制表示，其中hh表示小时，mm表示分钟。所有的房间从14:00开始可以使用。所有的房间必须腾空的时间在14:01到23:59之间（包括14:01和23:59）。
　　输入文件以一个数字0结束。', '　　对于输入中的每个测试数据，必须输出一行，包括两个整数，需要安排到帐篷中的专题讨论会的数量和需要参加帐篷中的专题讨论会的参加者的数量。注意按照输出样例中的个数输出。', '[{"input": "1\n20 60\n1\n30 16:00\n2\n20 60\n50 30\n1\n30 14:50\n0", "output": "Trial 1: 0 0\nTrial 2: 2 70"}]', 'f86509ee8014ff281ece0d19ee634c19', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);INSERT INTO problem_tag(name) VALUES('网络流');INSERT INTO problem_tag(name) VALUES('KM算法');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Workshops' limit 1),(select id from problem_tag where name='网络流' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Workshops' limit 1),(select id from problem_tag where name='KM算法' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Eyeball Benders', '　　"眼球风暴"是当下非常流行的一个游戏。在这个游戏中，玩家需要从一张近视图中识别出图中的物体是什么。比如，一张看起来像是锥形蜡笔的图可能是一个新开的蜡笔盒的图的一部分。下图展示了一个例子，左边的是给出的谜题，而右边则是解答。

　　图1，一个“眼球风暴”的给出的谜题和解答。（软盘）
　　你需要做的事是检验一个简化的“眼球风暴”的问题。我们会给你两张图，每张图都是一些线段的集合，且每条线段都是垂直于坐标轴的，并且每条线段都包括它的两个端点。
　　你需要确定第一张图是不是第二张图的某个部分的放大图。所有的线段都被认为是无宽度的。你需要保证，在第一张图中某条线段的端点在放大前一定是第二张图中某条线段的端点。

　　图2，第一张图是第二张图中画虚线区域放大三倍后的图。
　　坐标的单位和比例在同一张图内是一样的。一张图内的单位和比例不一定和另外一张图是一样的。第一张图的大小至少应该是原图中该部分的1倍。对于图2，你应该判定第一张图是第二张图的一部分。', '　　第一行有两个整数N、M，分别代表第一张图中的线段数量和第二张图中的线段数量。
　　接下来4*(N+M)个实数，每四个数分别代表一条线段的两个端点的坐标。前4*N个实数代表第一张图的N条线段，剩下的数代表第二张图的M条线段。所有的实数不会超过三位小数。所有的线段长度至少为0.005，线段之间不会覆盖只会相交。数据保证给出的N条线段不同向的线段间至少有一个交点。', '　　如果第一张图能够在第二张图中找到并且满足上述所有要求，那么输出“valid puzzle”，否则输出“impossible”。数据保证如果第一张图在第二张图中能够被找到，那么不被包括在答案矩形中的线段至少距离矩形0.005。', '[{"input": "3 12\n9 8 7.5 8 1.5 8 1.5 3.5\n0 5 9 5\n4 2 8 2 5 7 2 7 10 6 8 6 8 7 8 4\n1 9 8 9\n9 3 7 3 4 10 4 5\n4 2 4 4 5 8 5 7 3 6 6 6 0 3 3 3 5 1 5 3", "output": "valid puzzle"}]', 'd1e63a311491ebd35fde31c14f465e2b', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('计算几何');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Eyeball Benders' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Eyeball Benders' limit 1),(select id from problem_tag where name='计算几何' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('不大的数', '　　在当今的大数据时代，超大数的高精度计算已经成为众多领域的热门研究之一。现在T校也想在此领域有所造诣已造福于全社会，然而由于时间有限，所以短时间内难以找出大数计算的通用算法，于是学校找到了同学中的“神霸”——你来帮忙，并仅要求你能在数并不算大的时候给出结果。又出于某种特殊需要，也并不要求你给出数的全部结果，而只是要求结果的前10位（注意不是后10位），并考虑到2的幂次的特殊性和典型性，所以要你计算的数均为2的幂次。', '　　一个自然数n。', '　　2的n次幂的前10位。', '[]', 'e3de76a1a18196e91e1b1495b655b68c', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 7);INSERT INTO problem_tag(name) VALUES('高精度');INSERT INTO problem_tag(name) VALUES('精度估计');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='不大的数' limit 1),(select id from problem_tag where name='高精度' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='不大的数' limit 1),(select id from problem_tag where name='精度估计' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('快乐司机', '　　"嘟嘟嘟嘟嘟嘟
　　喇叭响
　　我是汽车小司机
　　我是小司机
　　我为祖国运输忙
　　运输忙"
　　这是儿歌“快乐的小司机”。话说现在当司机光有红心不行，还要多拉快跑。多拉不是超载，是要让所载货物价值最大，特别是在当前油价日新月异的时候。司机所拉货物为散货，如大米、面粉、沙石、泥土......
　　现在知道了汽车核载重量为w，可供选择的物品的数量n。每个物品的重量为gi,价值为pi。求汽车可装载的最大价值。（n<10000,w<10000,0<gi<=100,0<=pi<=100)', '　　输入第一行为由空格分开的两个整数n w
　　第二行到第n+1行，每行有两个整数，由空格分开，分别表示gi和pi', '　　最大价值（保留一位小数）', '[{"input": "5 36\n99 87\n68 36\n79 43\n75 94\n7 35", "output": "71.3\n解释：\n先装第5号物品，得价值35，占用重量7\n再装第4号物品，得价值36.346,占用重量29\n最后保留一位小数，得71.3"}]', 'fdfe65cea024a008997ca21a7ee05cd1', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('贪心');INSERT INTO problem_tag(name) VALUES('快排');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='快乐司机' limit 1),(select id from problem_tag where name='贪心' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='快乐司机' limit 1),(select id from problem_tag where name='快排' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Sharing Chocolate', '　　每天，巧克力在它的许多形式上被全世界数百万人分享。它是一个真正普遍的糖果，实际上在世界上每个国家都能得到。
　　你发现唯一比吃巧克力更好的事情是把它分享给朋友。不幸的是，你的朋友非常挑剔，有着不同的胃口：有的喜欢让你提供较多的巧克力，而其他的喜欢让你提供较少的巧克力。你发现当他们的要求可以相互叠加时，这个事情就变得越来越难决断。现在是写一个程序来一次性完全解决这个问题的时间！
　　你的巧克力是矩形的。巧克力由同样大小的矩形块组成。你可以沿着巧克力中行或者列的分割线将巧克力分成两块来分享你的巧克力。你可以重复地用同样手段将分成的小块继续分割。你的每个朋友坚持要得到巧克力中的一个矩形部分，这个部分包含一个确定地小块数。你也有些坚持心：如果这块巧克力能全部分给你的朋友，不剩下任何部分，你才会分割你的巧克力。
　　例如图9表示将一个由3×4个小块组成巧克力块分割3次，分成各自包含6、3、2、1个小块的4部分的一种方法。（这相当于输入样例中第一个测试数据。）
', '　　输入数据包含多组测试数据，每组测试数据描述一个要分享的巧克力块。每组测试数据的第一行包含一个整数n(1<=n<=15)，表示巧克力需要分割成的块数。第二行包含两个整数x、y，表示巧克力块的两个方向上的长度。第三行包含n个正整数，表示n个部分各自需要包含的小块数。
　　输入数据终止于只包含整数0的一行。', '　　对于每组测试数据，先输出它的测试点编号。然后输出将巧克力按照指定的方法分割是否有可能：如果可能，输出“Yes”，否则输出“No”。按照输出样例中的格式输出。', '[{"input": "4\n3 4\n6 3 2 1\n2\n2 3\n1 5\n0", "output": "Case 1: Yes\nCase 2: No"}]', 'dca664bdd7bd8048db8233f9ebafb392', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);INSERT INTO problem_tag(name) VALUES('状态压缩动态规划');INSERT INTO problem_tag(name) VALUES('记忆化搜索');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Sharing Chocolate' limit 1),(select id from problem_tag where name='状态压缩动态规划' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Sharing Chocolate' limit 1),(select id from problem_tag where name='记忆化搜索' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('12-2扑克排序', '　　扑克牌排序：构造扑克牌数组，对扑克牌进行排序。排序原则如下：数字从小到大是2-10、J、Q、K和A，花色从小到大是方块（diamond）、梅花（club）、红桃（heart）、黑桃（spade）。两张牌比较时先看数字，数字相同时看花色。要求对输入的扑克牌进行从小到大排序。
　　输入五张牌（表示黑桃2、红桃3、黑桃3、方块A和梅花J）： 2 s 3 h 3 s A d J c
　　输出结果应为：2 s  3 h 3 s J c A d数组长度固定为5。', '', '', '[]', 'f8e5ce9c3f1298827e3c1ae6454bb9df', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 13);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('7-1用宏求球的体积', '　　使用宏实现计算球体体积的功能。用户输入半径，系统输出体积。不能使用函数，pi=3.1415926,结果精确到小数点后五位。', '', '', '[{"input": "一个满足题目要求的输入范例。\n例：\n1.0", "output": "与上面的样例输入对应的输出。\n例：\n"}]', 'dc46b26858072cbb0e317b6635c4eecb', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 13);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('递推求值', '　　已知递推公式：

　　F(n, 1)=F(n-1, 2) + 2F(n-3, 1) + 5,

　　F(n, 2)=F(n-1, 1) + 3F(n-3, 1) + 2F(n-3, 2) + 3.

　　初始值为：F(1, 1)=2, F(1, 2)=3, F(2, 1)=1, F(2, 2)=4, F(3, 1)=6, F(3, 2)=5。
　　输入n，输出F(n, 1)和F(n, 2)，由于答案可能很大，你只需要输出答案除以99999999的余数。', '　　输入第一行包含一个整数n。', '　　输出两行，第一行为F(n, 1)除以99999999的余数，第二行为F(n, 2)除以99999999的余数。', '[{"input": "4", "output": "14\n\n21"}]', '851194c88127db9165b68c62fdc888c9', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);INSERT INTO problem_tag(name) VALUES('递推');INSERT INTO problem_tag(name) VALUES('矩阵乘法');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='递推求值' limit 1),(select id from problem_tag where name='递推' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='递推求值' limit 1),(select id from problem_tag where name='矩阵乘法' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('快速幂', '　　给定A, B, P，求(A^B) mod P。', '　　输入共一行。
　　第一行有三个数，N, M, P。', '　　输出共一行，表示所求。', '[{"input": "2 5 3", "output": "2"}]', '47ed8ef85e364dd3f85bf87f3c1ea894', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 19);INSERT INTO problem_tag(name) VALUES('快速幂');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='快速幂' limit 1),(select id from problem_tag where name='快速幂' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('3-1课后习题2', '　　编写一个程序，接受用户输入的10个整数，输出它们的和。', '', '　　要求用户的输出满足的格式。
　　例：输出1行，包含一个整数，表示所有元素的和。', '[{"input": "1 2 3 4 5 6 7 8 9 10", "output": "55"}]', '37ee4e1c3948a6b47cfe677b962d0f0b', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Mummy Madness', '　　在2011年ACM-ICPC World Finals上的一次游览中，你碰到了一个埃及古墓。
　　不幸的是，你打开了坟墓之后，才发现这是一个坏主意：突然之间，原本空无一物的沙漠上已经爬满了暴躁的木乃伊。（如果你也沉睡几千年而突然被惊醒，你也会变得如此暴躁的。）（幸运的是，当你做完这道题的时候，你醒来了，发现你在弗罗里达的酒店里。那些木乃伊只是一场梦。）
　　面对这一大堆疯狂的木乃伊，你唯一的机会就是试图在他们抓到你之前逃跑。问题是：假如你与木乃伊永不疲倦，那么经过多长时间你会被木乃伊抓到？
　　我们把沙漠看成一个正方形的网格，你与木乃伊轮流移动（你走出第一步）。轮到你时，你可以移动到相邻的8个格子之一，或者站着不动。轮到木乃伊时，每个木乃伊会移动到其相邻的格子之一，使得他与你的欧几里得距离尽量小（假设你与木乃伊都站在格子的中心位置）。允许多个木乃伊同时占据同一个格子。
　　在每个单位时间内，你先做出移动，然后木乃伊做出移动。如果你与任何一个木乃伊站在同一位置，你会被抓住。当然，你试图尽量长时间避免被抓住。经过多少单位时间你会被抓住呢？
　　下图描述了你被4个木乃伊追逐的例子。H代表你的初始位置，而M代表木乃伊的初始位置。以你的初始位置为原点，则经过4个单位时间后，你被初始位置为(3,4)的木乃伊抓住。
', '　　输入文件包含若干组数据。每组数据的第一行为一个数n(0≤n≤10^5)，表示沙漠中木乃伊的个数。接下来n行，每行两个整数x y，表示初始时在(x,y)有一个木乃伊。x,y的绝对值均不超过10^6。你的初始位置是(0,0)，保证一开始这里没有木乃伊。
　　输入文件以一行-1结束。', '　　对于每组测试数据，输出一行，包括它的编号和被抓住经过的最长时间（即你做出决策的次数）；或输出"never"，如果你有办法永远不被抓住。
　　请以样例输出的格式输出数据。', '[{"input": "4\n-3 5\n3 4\n-6 -2\n1 -5\n1\n0 -1\n-1", "output": "Case 1: 4\nCase 2: never"}]', '3e83fff7f0f8f00fc0e6a73319afe28a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);INSERT INTO problem_tag(name) VALUES('线段树');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Mummy Madness' limit 1),(select id from problem_tag where name='线段树' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('拿糖果', '　　妈妈给小B买了N块糖！但是她不允许小B直接吃掉。
　　假设当前有M块糖，小B每次可以拿P块糖，其中P是M的一个不大于根号下M的质因数。这时，妈妈就会在小B拿了P块糖以后再从糖堆里拿走P块糖。然后小B就可以接着拿糖。
　　现在小B希望知道最多可以拿多少糖。', '　　一个整数N', '　　最多可以拿多少糖', '[{"input": "15", "output": "6"}]', 'e89d87cb9d85807d1f45f6f5d2523bcc', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 7);INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='拿糖果' limit 1),(select id from problem_tag where name='动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Asteroid Rangers', '　　这是2112年，人类已经征服了太阳系。太空游侠队已经在任何大块岩石上建立了基地（即使不适宜居住）。你作为小行星通讯部门的一员，工作是确保所有太空游侠小行星基地都能尽可能廉价地与其他小行星基地交流。你可以建立从每个基地到另外所有基地的直接交流连接，但那可能过分昂贵。相反，你想要建立最少数量的连接从而每个人都可以发送信息给其他所有人，信息可能通过一个或多个基地中转。建立任何连接的费用与它连接的两个基地之间的（欧几里德）距离成比例，所以这个问题看起来不怎么难。
　　但这只是一个小小的困难。小行星有一个运动的趋势，所以两个当前很接近的基地在将来不一定还是很接近。因此随着时间流逝，你一定会乐意转换你的交流连接，从而在任何时候你都拥有最廉价的中继系统。转换这些连接花费时间和金钱，所以你对于了解将要执行多少次转换很感兴趣。
　　一些假设让这个任务更简单。每个小行星可以视为一个点。小行星总是以固定的速度沿直线运动。没有小行星会和其他小行星相撞。此外，任何在时刻t(t≥0)变得最优的中继系统在任何时刻s(s满足t<s<t+10^-6)时是独一无二最优的。初始最优的中继系统也是独一无二的。', '　　每组数据（tsinsen上的数据均为单组数据）以包含一个整数n的一行开始，其中n表示小行星基地的数量。
　　接下来n行，每行包含6个整数x,y,z,vx,vy,vz，前三个表示这个小行星的初始位置，后三个表示小行星在x,y,z三维上的速度（单位空间每单位时间）。', '　　对于每组数据，输出一行，包含数据编号和中继系统需要被建立或修改的次数。', '[{"input": "3\n0 0 0 0 0 0\n5 0 0 0 0 0\n10 1 0 -1 0 0\n4\n0 0 0 1 0 0\n0 1 0 0 -1 0\n1 1 1 3 1 1\n-1 -1 2 1 -1 -1", "output": "Case 1: 3\nCase 2: 3"}]', '9fe01bbd5ba0505c78b5423fd6b7ec09', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 6);INSERT INTO problem_tag(name) VALUES('事件点');INSERT INTO problem_tag(name) VALUES('最小生成树');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Asteroid Rangers' limit 1),(select id from problem_tag where name='事件点' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Asteroid Rangers' limit 1),(select id from problem_tag where name='最小生成树' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('字符串跳步', '　　给定一个字符串，你需要从第start位开始每隔step位输出字符串对应位置上的字符。', '　　第一行一个只包含小写字母的字符串。

　　第二行两个非负整数start和step，意义见上。', '　　一行，表示对应输出。', '[{"input": "abcdefg\n2 2", "output": "ceg"}]', 'daaef045812525773d7c33907fc21411', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('字符串');INSERT INTO problem_tag(name) VALUES('循环');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='字符串跳步' limit 1),(select id from problem_tag where name='字符串' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='字符串跳步' limit 1),(select id from problem_tag where name='循环' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('11-2删除重复元素', '　　为库设计新函数DelPack，删除输入字符串中所有的重复元素。不连续的重复元素也要删除。
　　要求写成函数，函数内部使用指针操作。', '', '', '[{"input": "else", "output": "ls"}]', '831a8d47d526729ef73fe44c5dcf9f10', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 1);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('组合公式求值', '　　给定n, m，求：

', '　　输入一行，包含两个整数n, m。', '　　输出一行，包含求得的值，由于答案可能非常大，请输出此公式除以987654321的余数。', '[{"input": "3 1", "output": "162"}]', '70048a1628f717cabb5eacbcbf25ee8c', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 1);INSERT INTO problem_tag(name) VALUES('组合公式');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='组合公式求值' limit 1),(select id from problem_tag where name='组合公式' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('简单加法', '　　小于10的自然数中有四个数字能除尽3或5（3， 5， 6， 9），它们的和为23。
　　请计算所有小于1000的自然数中能除尽3或5的数字的合。然后使用标准输出cout，输出你的结果。', '　　无。', '　　一行一个整数，表示你的结果。', '[]', 'f1fa3900cbaf92236e21b23627be19bb', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);INSERT INTO problem_tag(name) VALUES('加法');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='简单加法' limit 1),(select id from problem_tag where name='加法' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('8-1因式分解', '　　设计算法，用户输入合数，程序输出若个素数的乘积。例如，输入6，输出2*3。输入20，输出2*2*5。', '', '', '[]', '7618d00b4c1ad23094b4b5bc7138bc1e', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 1);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('学霸的迷宫', '　　学霸抢走了大家的作业，班长为了帮同学们找回作业，决定去找学霸决斗。但学霸为了不要别人打扰，住在一个城堡里，城堡外面是一个二维的格子迷宫，要进城堡必须得先通过迷宫。因为班长还有妹子要陪，磨刀不误砍柴功，他为了节约时间，从线人那里搞到了迷宫的地图，准备提前计算最短的路线。可是他现在正向妹子解释这件事情，于是就委托你帮他找一条最短的路线。', '　　第一行两个整数n， m，为迷宫的长宽。
　　接下来n行，每行m个数，数之间没有间隔，为0或1中的一个。0表示这个格子可以通过，1表示不可以。假设你现在已经在迷宫坐标(1,1)的地方，即左上角，迷宫的出口在(n,m)。每次移动时只能向上下左右4个方向移动到另外一个可以通过的格子里，每次移动算一步。数据保证(1,1)，(n,m)可以通过。', '　　第一行一个数为需要的最少步数K。
　　第二行K个字符，每个字符∈{U,D,L,R},分别表示上下左右。如果有多条长度相同的最短路径，选择在此表示方法下字典序最小的一个。', '[{"input": "Input Sample 1:\n3 3\n001\n100\n110\n\nInput Sample 2:\n3 3\n000\n000\n000", "output": "Output Sample 1:\n4\nRDRD\n\nOutput Sample 2:\n4\nDDRR"}]', '1f017c872eef819c0e020eab795af00a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 10);INSERT INTO problem_tag(name) VALUES('广搜');INSERT INTO problem_tag(name) VALUES('bfs');INSERT INTO problem_tag(name) VALUES('经典问题');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='学霸的迷宫' limit 1),(select id from problem_tag where name='广搜' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='学霸的迷宫' limit 1),(select id from problem_tag where name='bfs' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='学霸的迷宫' limit 1),(select id from problem_tag where name='经典问题' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('2-1屏幕打印', '', '', '', '[]', '384275dd194e924f72c89124009829fa', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 16);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Light Bulbs', '　　好莱坞最新的剧院“the Atheneum of Culture and Movies”拥有一个由计算机控制的成千上万个灯泡组成的巨型荧幕。每行灯泡都用由电脑操作的一系列开关控制。不幸的是，电工接错了开关的型号，并且今天晚上就是ACM的开幕式。你需要写个程序让这些开关正确的运作。
　　荧幕的一排有n个灯泡，它们被n个开关控制。灯泡和开关都从左至右依次编号为1到n。每个灯泡要么是开的，要么是关的。每组输入数据含有一排灯泡的起始状态和目标状态。
　　最初的计划是让一个开关控制一个灯泡。但是电工的失误导致了每个开关控制2或3个灯泡，如图1所示。最左边的开关（i=1）控制最左边的两个灯泡（1和2）；最右边的灯泡（i=n）控制最右边的两个灯泡（n-1和n）。剩下的开关（1<i<n）控制3个灯泡i-1，i和i+1。（特别的，如果只有1个灯泡，那么就只有1个开关控制那唯一的灯泡。）也就是说，如果灯泡1是开的，灯泡2是关的，转换开关1则会导致灯泡1关上，灯泡2打开。最少的代价是指将这一排灯泡从初始状态转换到最终状态所需要转换的最少的开关数。
　　你可以将一排开关的状态表示为二进制数，0表示关，1表示开。举例来说，01100表示一排5个灯泡，其中第二个和第三个是开的。如果要把这个状态转化到10000，可以转换开关1、4、5，或者转换开关2。
　　你需要写个程序来决定最少转换哪些开关使得这排灯泡从初始状态变为目标状态。有些初始状态和目标状态是无解的。为了压缩数据，我们用10进制来输入。也就是说，01100和10000将用12和16来表示。
', '　　输入数据有多个case。每个case一行，2个非负整数，其中至少有一个是整数，并且不超过100个数字。第一个数字表示开始状态，第二个数字表示目标状态。这些数字化为2进制后表示一行灯泡的状态，1是开，0是关。
　　为了避免二进制数中出现前导0的问题，数据保证第一个灯泡要么在起始状态是亮的，要么是在目标状态是亮的（或者都是亮的）。输入保证没有多余的空格，输入的10进制数中没有前导0，两个数由一个空格隔开。', '　　对每个case，输出一行。包括case编号和一个十进制数。这个十进制数表示在最小代价下，需要转换的开关的状态。也就是说如果把这个数转为2进制后，最右边的位（最低位）代表第n个开关的状态，1表示开关转换过，0表示没有。如果无解，输出“impossible”。如果有多组解，输出转成十进制后最小的那一个。
　　在每个case间输出一个空行，用输出样例显示的格式输出。', '[{"input": "12 16\n1 1\n3 0\n30 5\n7038312 7427958190\n4253404109 657546225\n0 0", "output": "Case Number 1: 8\n\nCase Number 2: 0\n\nCase Number 3: 1\n\nCase Number 4: 10\n\nCase Number 5: 2805591535\n\nCase Number 6: impossible"}]', 'b2d53254545c9cbfd28f961cd1e31c57', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 6);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('高精度');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Light Bulbs' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Light Bulbs' limit 1),(select id from problem_tag where name='高精度' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('简单计算器', '　　编程模拟计算器的加、减、乘、除功能，根据用户输入的运算符，对两个数进行运算。(要求switch语句)', '　　输入只有一行，用空格隔开的运算符和两个运算数，运算符一定是+, -, *, /之一，运算数一定是绝对值不超过200的整数，当运算符为除号时，除数不为0并第一个数一定是第二个数的整数倍。', '　　输出只有一行，包含一个整数，表示运算结果。', '[{"input": "/ 6 2", "output": "3"}]', 'f813a2b708a29369d4d003e7e7895482', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('语言');INSERT INTO problem_tag(name) VALUES('switch语句');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='简单计算器' limit 1),(select id from problem_tag where name='语言' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='简单计算器' limit 1),(select id from problem_tag where name='switch语句' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('House of Cards', '　　Axel和Birgit喜欢玩这样的一种纸牌游戏：他们建造一个由纸牌组成的房子，当他们添加纸牌到房子的时候，会获得（或失去）游戏的分数。由于他们都有一双灵巧的手，纸牌组成的房子是不会倒塌的。他们使用半副标准纸牌。一副标准的纸牌有4种花色，2种是红色，2种是黑色。Axel和Birgit只使用2种花色，1红1黑。每种花色有13个等级。我们使用记号1R，2R，…，13R，1B，2B，…，13B来表示等级和颜色。
　　开始前，玩家要选择半副标准纸牌的一个子集，子集中所有纸牌的最大等级是M。洗完选出的纸牌后，他们从牌堆的最上面拿出8张，从左到右连续地放置它们形成4个“山峰”。举个例子，如果M=13而且前10张纸牌（26张的前10张）是：
　　6B 3R 5B 2B 1B 5R 13R 7B 11R 1R …
　　那么这个游戏开始的时候就像图7所展示的那样。



　　剩下的纸牌正面朝上被放置成一排。
　　每个玩家被认定一种颜色，红色或黑色。Birgit总被认定是黑色，Axel总被认定是红色。第一张用于组成山峰和山谷的纸牌的颜色决定了哪个玩家先开始。图7的那个例子，Birgit先开始，因为第一张纸牌是6B。
　　玩家交替进行操作。一步操作包括从一排纸牌的最前面抽取一张纸牌然后进行下列的一条：
　　1．持有这张纸牌直到下次操作（这是一张“被持有的纸牌”）。
　　2．用刚抽取的纸牌或被持有的纸牌覆盖在两个山峰之间的山谷，形成一个“基底”。如果还剩下一张牌，那么这张牌就被持有。
　　3．把2张纸牌放在基底上面，形成一个山峰（其中一张纸牌一定是一张被“持有”的纸牌）。
　　不是所有的选择总是可行的。任何时候最多持有1张纸牌，所以第一个选择只有当这个玩家没有持有纸牌时才可行。
　　因为排成一排的纸牌是正面朝上，所以两个玩家在纸牌被抽取前就事先知道纸牌的顺序。
　　如果玩家通过添加了一个基底组成了一个向下的三角形，或者通过添加了一个山峰组成了一个向上的三角形，那么玩家的分数就会像下面描述的那样更新。组成三角形的3张纸牌的等级之和将被增加到那个颜色与3张纸牌的多数颜色相等的那个玩家的分数上。如果在游戏中没有组成三角形，两个玩家的分数保持不变。
　　图7的那个例子，如果Birgit放置她的纸牌（11R）到中间的山谷上，她将获得14分。如果她放置她的纸牌到左边的山谷上，Axel获得19分。如果她放置她的纸牌到右边的山谷上，Axel获得29分。
　　如果在某步操作结束后没有纸牌等待被抽取，这个游戏就结束了。如果某个玩家在这个时候持有纸牌，那个玩家的分数将会增加（或减少）这张纸牌的等级如果这张纸牌的颜色与玩家颜色相同（不同）。
　　当这个游戏结束后，分数低的玩家将要支付一定数量的瑞典克朗给另一个玩家，数量等同于两个玩家的分数差。如果是平局，就不用支付。
　　你必须写一个程序读入一副被洗过的牌堆和一个玩家的名字，然后找出这个玩家最多能赢多少（或者最少能输多少），假设另一个玩家总是采取最优策略。', '　　读入包含多组测试数据代表多个游戏。每组测试数据包含一个名字（Axel或者Birgit），然后会有1个最大的等级M（5 ≤ M ≤ 13），紧接着有2M张纸牌的等级和颜色，按在牌堆中的位置给出。每一个等级（从1到M）和颜色的组合在序列中只会出现一次。初始序列的前8张按抽出的顺序从左到右组成山峰，剩下的显示了纸牌的顺序。
　　包含单词End的一行紧跟在最后一组数据后面。', '　　对于每个测试数据，输出数据的编号（从1开始），这组数据中玩家的名字，和这个玩家赢或输了多少分数。如果是平局，指出是平局而不是输出数字。参照样例输出的格式。', '[{"input": "Axel\n5\n1R 2R 3R 4R 5R 5B 4B 3B 2B 1B\nBirgit\n5\n1R 2R 3R 4R 5R 5B 4B 3B 2B 1B\nBirgit\n5\n1R 1B 3R 4R 5R 5B 4B 3B 2R 2B\nEnd", "output": "Case 1: Axel wins 1\nCase 2: Birgit loses 1\nCase 3: Axel and Birgit tie"}]', 'dce6f8272b7719d2bf7c7db52970edaa', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('搜索');INSERT INTO problem_tag(name) VALUES('alphabeta剪枝');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='House of Cards' limit 1),(select id from problem_tag where name='搜索' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='House of Cards' limit 1),(select id from problem_tag where name='alphabeta剪枝' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('第二大整数', '　　编写一个程序，读入一组整数（不超过20个），当用户输入0时，表示输入结束。然后程序将从这组整数中，把第二大的那个整数找出来，并把它打印出来。说明：（1）0表示输入结束，它本身并不计入这组整数中。（2）在这组整数中，既有正数，也可能有负数。（3）这组整数的个数不少于2个。
　　输入格式：输入只有一行，包括若干个整数，中间用空格隔开，最后一个整数为0。
　　输出格式：输出第二大的那个整数。
　　输入输出样例', '', '', '[{"input": "5 8 -12 7 0", "output": "7"}]', '393e7e160056e9bab8856023b62eb4c1', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('逻辑判断');INSERT INTO problem_tag(name) VALUES('循环语句');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='第二大整数' limit 1),(select id from problem_tag where name='逻辑判断' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='第二大整数' limit 1),(select id from problem_tag where name='循环语句' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('逆序排列', '　　编写一个程序，读入一组整数（不超过20个），并把它们保存在一个整型数组中。当用户输入0时，表示输入结束。然后程序将把这个数组中的值按逆序重新存放，并打印出来。例如：假设用户输入了一组数据：7 19 -5 6 2 0，那么程序将会把前五个有效数据保存在一个数组中，即7 19 -5 6 2，然后把这个数组中的值按逆序重新存放，即变成了2 6 -5 19 7，然后把它们打印出来。
　　输入格式：输入只有一行，由若干个整数组成，中间用空格隔开，最末尾的整数为0。
　　输出格式：输出也只有一行，即逆序排列后的整数，中间用空格隔开，末尾没有空格。
　　输入输出样例', '', '', '[{"input": "7 19 -5 6 2 0", "output": "2 6 -5 19 7"}]', 'f7edea4653b64de4954760b64c6e8f52', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 17);INSERT INTO problem_tag(name) VALUES('循环语句');INSERT INTO problem_tag(name) VALUES('数组操作');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='逆序排列' limit 1),(select id from problem_tag where name='循环语句' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='逆序排列' limit 1),(select id from problem_tag where name='数组操作' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('7-2求arccos值', '　　利用标准库中的cos(x)和fabs(x)函数实现arccos(x)函数，x取值范围是[-1, 1]，返回值为[0, PI]。要求结果准确到小数点后5位。(PI = 3.1415926)
　　提示：要达到这种程度的精度需要使用double类型。', '', '', '[{"input": "0.5", "output": ""}]', '38144059b7750cb1d2e6cee77ef3ffec', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('林丹大战李宗伟', '　　我们用0表示林丹，1表示李宗伟。

　　输入数据中每行会给出一个0或者1，表示对应选手得1分。

　　当一方得分达到21分时，只要该方与对方分差超过1分，该方即胜出。

　　你需要输出最后获胜选手的代号。', '　　若干行每行一个0或者1。', '　　一行一个0或者1表示胜者。', '[{"input": "1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1", "output": "1"}]', 'fcd05dbeff08e30bbc922234cd448a8f', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 18);INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tag(name) VALUES('条件判断');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='林丹大战李宗伟' limit 1),(select id from problem_tag where name='模拟' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='林丹大战李宗伟' limit 1),(select id from problem_tag where name='条件判断' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('A Careful Approach', '　　如果你认为参加一个编程比赛让你感到有压力，那么请你想象你是一个空中交通管制员。因为人命关天，所以一个空中交通管制员必须在时刻变化的环境中专注于任务，解决不可预知的事件。
　　让我们将目光转向飞机的着陆流程。飞机进入目的地飞航情报区之后，就会报告自己的位置、方向和速度，然后管制员就需要制定计划让所有飞机按指令安全着陆。一般来说，连续的两次着陆之间间隔时间越长，就越安全。因为这些额外的时间能够让工程师有机会对天气变化以及其他突发事件作出反应。
　　幸运的是，有一部分计划的制定可以自动化——这就是你来这里的原因。你会得到有关飞机着陆的脚本。每一个飞机都有一个安全着陆时间窗。你算出的指令必须要符合每个飞机的时间窗。另外，飞机的着陆时间点要尽量均匀，使得连续两次着陆的最小间隔尽量大。例如，如果三架飞机分别着陆于10:00am、10:05am、10:15am，那么最小间隔是五分钟，在头两架飞机之间。所有间隔不一定一样，但是最小的间隔要尽量大。', '　　多组数据。每个数据第一行为一个整数n，为飞机架数。接下来n行，每行两个整数a[i]，b[i]表示这架飞机只能在闭区间[a[i],b[i]]间降落。a[i]和b[i]的单位是分钟。输入的最后一行是一个零。', '　　对于每组数据，先输出第几组，然后输出最小间隔，单位为分和秒，舍入到最近的整数。格式参见样例。', '[{"input": "3\n0 10\n5 15\n10 15\n2\n0 10\n10 20\n0", "output": "Case 1: 7:30\nCase 2: 20:00"}]', '63c1b5032f599fedbc302b458ec70374', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);INSERT INTO problem_tag(name) VALUES('二分');INSERT INTO problem_tag(name) VALUES('贪心');INSERT INTO problem_tag(name) VALUES('暴力');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='A Careful Approach' limit 1),(select id from problem_tag where name='二分' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='A Careful Approach' limit 1),(select id from problem_tag where name='贪心' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='A Careful Approach' limit 1),(select id from problem_tag where name='暴力' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Navigation', '　　全球定位系统（GPS）是一个导航系统，根据一些在距地表大约20,000千米的轨道运行的卫星。每个卫星在一个已知的轨道上运行，发射编码着当前时间的无线电信号。如果一个装有全球定位系统的交通工具有一个非常精确的时钟，它就可以比较它自己的当地时间和从卫星上接受到的编码成信号的时间。因为无线电信号按一个已知的速度传播，所以这个交通工具能够计算出它目前的位置和信号发出时卫星的位置之间的距离。通过测算这个交通工具和一些在已知轨道上运行的卫星之间的距离，它可以非常精确地计算出自己的位置。




　　你必须写一个简单的“自动导航装置”程序，根据GPS的导航。为了让这个问题更简单，我们描述一个二维的问题。换句话说，你不需要考虑地球的曲率或者卫星的高度。此外，这个问题使用了更加适合于飞机和声波的速度而不是卫星和无线电波。
　　给定一组移动的信号源，你的程序必须计算出在笛卡尔平面内的接收点。然后，给定一个在平面内的目标点，你的程序必须计算出从接收点到目标点指南针的指向。所有的指南针的指向用角度表示。指南针指向0（北）相当于Y轴方向，指南针指向90（东）相当于X轴方向，就像图1所展示的那样。', '　　读入包含多组测试数据。
　　每组数据的第一行包含一个整数N （1 ≤ N ≤ 10），表示信号源的数量。接下来有3个浮点数：t，x和y。这里，t表示当所有的信号被接收时精确的当地时间，从基准时间（0时刻）按秒计时算起；x和y表示在笛卡尔平面内目标点的坐标。接下来N行每行包含4个浮点数，携带有1个信号源的信息。前2个数字表示信号源在基准时间在笛卡尔平面内的位置。第3个数字表示信号源向指南针指向D（0 ≤ D < 360）前进。第4个数字是编码在信号里的时间——也就是，信号发出的时间，从基准时间按秒计时算起。输入文件所有数字小于10000，没有一个浮点数在小数点后超过5位。
　　最后一组数据的接下来一行包含4个0。
　　坐标系的单位距离是1m。假设每个信号源以100m/s的速度在笛卡尔平面上移动，信号以350m/s的速度传播。由于时钟同步的不精确，你计算的距离都只精确到0.1m。也就是说，如果2个点相距0.1m以内，你应该把它们看成相同的点。信号可能在传播途中被干扰，所以接收到的多个信号可能会矛盾。', '　　对于每组数据，输出数据的编号和从接收位置到目的地指南针的指向，用角度表示，四舍五入到整数。使用在样例输出中展示的标识。如果信号包含不够多的信息来计算接收位置（也就是，符合所有信号的超过一个位置），输出“Inconclusive”。如果信号矛盾（也就是，没有位置符合所有的信号），输出“Inconsistent”。如果接收位置相距目的地0.1m以内，输出“Arrived”。如果情形是Inconclusive或者Inconsistent，那么你不需要考虑Arrived的情形。
　　图2对应着样例的第一个数据。t=0时3个卫星的位置A（-100，350），B（350，-100），和C（350，800）。被GPS装置接收的信号都在t=1.75时被发出，当卫星处在位置A ，B ，C 的时候（然而，通常被GPS装置接收的信号发出的时刻是不同的）。3个卫星发出信号在t=2.53571时刻汇聚在D，意味着D是接收信号的GPS装置的位置。从点D出发，指南针指向45度最终会到达目的地（1050，1050）。', '[{"input": "3 2.53571 1050.0 1050.0\n-100.0 350.0 90.0 1.75\n350.0 -100.0 0.0 1.75\n350.0 800.0 180.0 1.75\n2 2.0 1050.0 1050.0\n-100.0 350.0 90.0 1.0\n350.0 -100.0 0.0 1.0\n0 0 0 0", "output": "Trial 1: 45 degrees\nTrial 2: Inconclusive"}]', 'c3409a5643830836b8f9fd8fc8ca8bd1', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('解方程');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Navigation' limit 1),(select id from problem_tag where name='解方程' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('8皇后·改', '　　规则同8皇后问题，但是棋盘上每格都有一个数字，要求八皇后所在格子数字之和最大。', '　　一个8*8的棋盘。', '　　所能得到的最大数字和', '[{"input": "1  2  3  4  5  6  7  8\n9 10 11 12 13 14 15 16\n17 18 19 20 21 22 23 24\n25 26 27 28 29 30 31 32\n33 34 35 36 37 38 39 40\n41 42 43 44 45 46 47 48\n48 50 51 52 53 54 55 56\n57 58 59 60 61 62 63 64", "output": "260"}]', '58678bdffaf0c470df735dd082d91dd6', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);INSERT INTO problem_tag(name) VALUES('DFS');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='8皇后·改' limit 1),(select id from problem_tag where name='DFS' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('阶乘差', '　　给定n和m以及p，保证n>=m，求(n!-m!)对p取余的结果。', '　　一行三个正整数n,m,p。', '　　一行一个非负整数表示结果。', '[{"input": "3 2 10", "output": "4"}]', '8fb61d984f675d9fa5bae690ea070182', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 10);INSERT INTO problem_tag(name) VALUES('循环');INSERT INTO problem_tag(name) VALUES('取余');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='阶乘差' limit 1),(select id from problem_tag where name='循环' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='阶乘差' limit 1),(select id from problem_tag where name='取余' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('3-2求存款', '　　见计算机程序设计基础（乔林）P50第5题。
　　接受两个数，一个是用户一年期定期存款金额，一个是按照百分比格式表示的利率，计算一年期满后的本金与利息总额。说明：(1)  存款金额以人民币元为单位，精确到分；(2)  输入利率时不输入百分号，例如利率为3.87%，用户直接输入3.87；(3)  按照国家法律，存储利息所得需缴纳5%的所得税，计算结果时应当扣除所得税。(4)  显示的结果精确到人民币分。
　　注意：数据须用float表示；计算结果须保存到一个float变量中，再用printf输出。', '　　一行，以一个空格隔开的两个浮点数。', '　　一个浮点数。', '[{"input": "5000.00 5.00", "output": "5237.50"}]', '4d93cc2cec629e42fe0f59ebd4f6ab35', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 12);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('征税程序', '　　税务局希望你帮他们编写一个征税程序，该程序的功能是：首先输入某公司的年销售额sale和税率rate，然后程序将计算出相应的税额tax，并把它显示在屏幕上。计算公式是：
　　tax = sale * rate。
　　输入格式：输入只有一行，包括两个数据，即年销售额和税率。
　　输出格式：输出只有一行，包括一个实数，即相应的税额，保留到小数点后两位。
　　输入输出样例', '', '', '[{"input": "50000.5 0.1", "output": "5000.50"}]', 'aa867e0751cb924083d4c112f0c139b7', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 1);INSERT INTO problem_tag(name) VALUES('基本运算');INSERT INTO problem_tag(name) VALUES('数学知识');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='征税程序' limit 1),(select id from problem_tag where name='基本运算' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='征税程序' limit 1),(select id from problem_tag where name='数学知识' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('9-3摩尔斯电码', '　　摩尔斯电码破译。类似于乔林教材第213页的例6.5，要求输入摩尔斯码，返回英文。请不要使用"zylib.h"，只能使用标准库函数。用  *  表示  .  ，中间空格用  |  表示，只转化字符表。

　　摩尔斯码定义见：http://baike.baidu.com/view/84585.htm?fromId=253988。

', '', '', '[]', '6b8a7dd396f4d43b212f06da60570f4a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('温度转换', '　　编写一个程序，输入一个摄氏温度，输出相应的华氏温度。在输出时，保留小数点后面两位。
　　输入格式：输入只有一个整数，即摄氏温度。
　　输出格式：输出只有一实数，即相应的华氏温度。
　　输入输出样例', '', '', '[{"input": "35", "output": "95.00"}]', 'f5e9d543d46ecb2c23e44b69f6fbb4b8', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 3);INSERT INTO problem_tag(name) VALUES('基本运算');INSERT INTO problem_tag(name) VALUES('数学知识');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='温度转换' limit 1),(select id from problem_tag where name='基本运算' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='温度转换' limit 1),(select id from problem_tag where name='数学知识' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('GDP计算', '　　设我国国民生产总值的年增产率为10%，计算n年后我国国民生产总值与现在的比是多少。计算公式为：P=(1+r)n, r为年增产率，n为年数，P为n年后国民生产总值与现在相比的倍数。', '　　输入一个数n(1 <= n <= 300)。', '　　输出一个数P，保留2位小数。', '[{"input": "10", "output": "2.59"}]', 'c4fef7b105edb732e3e9c8ef6121b44e', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);INSERT INTO problem_tag(name) VALUES('语言');INSERT INTO problem_tag(name) VALUES('循环');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='GDP计算' limit 1),(select id from problem_tag where name='语言' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='GDP计算' limit 1),(select id from problem_tag where name='循环' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('队列操作', '　　﻿队列操作题。根据输入的操作命令，操作队列（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。', '　　第一行一个数字N。
　　下面N行，每行第一个数字为操作命令（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。', '　　若干行每行显示一个2或3命令的输出结果。注意：2.出队命令可能会出现空队出队（下溢），请输出“no”，并退出。', '[{"input": "7\n1 19\n1 56\n2\n3\n2\n3\n2", "output": "19\n1\n56\n0\nno"}]', '8ae378494f5786690caf91bdbbd498e4', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 6);INSERT INTO problem_tag(name) VALUES('queue');INSERT INTO problem_tag(name) VALUES('队列');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='队列操作' limit 1),(select id from problem_tag where name='queue' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='队列操作' limit 1),(select id from problem_tag where name='队列' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('身份证号码升级', '　　从1999年10月1日开始，公民身份证号码由15位数字增至18位。(18位身份证号码简介)。升级方法为：
　　1、把15位身份证号码中的年份由2位(7,8位)改为四位。
　　2、最后添加一位验证码。验证码的计算方案：
　　将前 17 位分别乘以对应系数 (7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2)  并相加，然后除以 11 取余数，0-10 分别对应 1 0 x 9 8 7 6 5 4 3 2。
　　请编写一个程序，用户输入15位身份证号码，程序生成18位身份证号码。假设所有要升级的身份证的四位年份都是19××年', '　　一个15位的数字串，作为身份证号码', '　　一个18位的字符串，作为升级后的身份证号码', '[{"input": "110105491231002", "output": "11010519491231002x"}]', 'c46d77c5de5df5157a71b21a5a31d9f5', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 19);INSERT INTO problem_tag(name) VALUES('字符串');INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='身份证号码升级' limit 1),(select id from problem_tag where name='字符串' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='身份证号码升级' limit 1),(select id from problem_tag where name='模拟' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('11-1实现strcmp函数', '　　自己实现一个比较字符串大小的函数，也即实现strcmp函数。函数：int myStrcmp(char *s1,char *s2) 按照ASCII顺序比较字符串s1与s2。若s1与s2相等返回0，s1>s2返回1，s1<s2返回-1。具体来说，两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇 \0 为止（注意 \0 值为0，小于任意ASCII字符）。如：
　　"A"<"B"
　　"a">"A"
　　"computer">"compare"
　　"hello"<"helloworld"', '', '', '[]', 'abdf6b4612eab5db7379ce9d59708aeb', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 18);INSERT INTO problem_tag(name) VALUES('指针');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='11-1实现strcmp函数' limit 1),(select id from problem_tag where name='指针' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('题目1 最大最小', '　　给定 N 个整数，请你找出这 N 个数中最大的那个和最小的那个。', '　　第一行包含一个正整数 N 。(1 ≤ N ≤ 10000)。
　　第二行为 N 个用空格隔开的整数,每个数的绝对值不超过 1000000。', '　　输出仅一行,包含两个整数 x,y，x 表示 N 个数中的最大值，y 表示 N 个数中的最小值。x,y 之间用一个空格隔开。', '[{"input": "4\n2 0 1 2", "output": "2 0"}]', 'd76e34c6858551c82402e785a12d9855', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 3);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Contour Mapping', '　　等高线图可以描绘一个区域的地势。等高线图上的等高线代表等高海拔。比如，一张等高线图上可能有一条线代表海拔100米的区域，另一条代表海拔200米的区域等等。
　　等高线图绘制协会（Association for Contour Mapping，简称ACM）需要程序读取从卫星获取的海拔信息并绘制等高线图。ACM尤其关注每张地图上所有等高线的长度之和。海拔信息的形式为一个整数序列，依次代表在一条从西往东的扫描线上取的等距离的点的海拔。扫描线间距的取值使得测量区域内所有不在边缘的每个测高点都有6个其他的测高点离它最近，而且相互等距（这里忽视海拔高度），如图1和图2所示。

　　ACM的做法是，用线段连接每个点与距其最近的所有点，构造出许多三角形，并用这些三角形来估计实际地形。每个三角形会被视为一个平面，由其三个顶点的坐标和海拔确定。如果把三角形投影到海平面上，这些三角形会是等边三角形。
　　在上图中，黑色的数字代表海拔信息，红色虚线和数字代表等高线。图1中有一条海拔为5的等高线。图2中在海拔为6和9之处分别有一条等高线。等高线可以穿过三角形的内部或者紧贴三角形的一边。
　　由于测高点的特殊选取方式，编号为偶数的扫描线较之于编号为奇数的扫描线上会多取一个测高点。图中最上面的一条线是第一条扫描线。', '　　输入第一行有4个整数s、p、d和h。
　　s代表扫描线的条数。
　　p代表编号为奇数的扫描线上的测高点数，编号为偶数的扫描线上有p+1个测高点。
　　d代表无视海拔时，每个测高点与距其最近的测高点的距离（即三角形的边长）。
　　h代表等高线的海拔间隔。在最后的等高线图中，在所有海拔为h的整数倍的地方都会有一条等高线。注意一张地图上同一海拔的等高线可能有多条。当一整块区域水平时，只在边界处有等高线（见图2中海拔为9的等高线）。
　　接下来共s行，每行描述一条扫描线。对于奇数行，每行含有p个整数，从左到右表示扫描线上测高点的数据。对于偶数行，每行含有p+1个整数，从左到右表示扫描线上测高点的数据。每个数字都是不超过10^6的非负整数。', '　　输出一个整数，表示绘制的等高线图上所有等高线的长度之和，四舍五入到最近的整数。', '[{"input": "4 3 5 5\n0 5 5\n0 0 0 5\n0 10 0\n0 0 0 20", "output": "88"}]', '998d6d284b20da795cf2d7d09a549a68', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);INSERT INTO problem_tag(name) VALUES('计算几何');INSERT INTO problem_tag(name) VALUES('实现');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Contour Mapping' limit 1),(select id from problem_tag where name='计算几何' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Contour Mapping' limit 1),(select id from problem_tag where name='实现' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Subway Timing', '　　和很多现代化的城市一样，斯德哥尔摩有一个发达的公共交通系统。而斯德哥尔摩公共交通的核心就是地铁。一份地铁的拓扑地图里有不同的地铁线路，以及他们之间的连接方式，如下图。在这个问题中，你可以假定地铁的地图一定是树形的，尽管斯德哥尔摩的地铁实际上并非确实如此，例如图中蓝色和绿色的线路形成了一个环。

　　地铁的拓扑图并不关心地铁系统的几何性质，比如说不同地铁站之间的距离（以及相应的旅行时间）。虽然斯德哥尔摩的大部分学生都知道，“Tekniska Hogskolan” (皇家理工学院) 和 “Universitetet” (斯德哥尔摩大学)相隔是非常远的，但是如上这幅图中却没有体现出来。
　　为了丰富这张地图，你要写一个程序，计算出任意相邻地铁站之间所需的旅行时间。幸运的是，那些旅行时间是已知的，所以不需要你亲自去测量。但问题是，实际测量出来的时间是以秒为单位，而画在地图上的时间却是以分钟为单位，而且必须是整数，所以需要你给出一个时间的估计。
　　一种自然的估计时间的方法可能是简单地将所有的旅行时间转往离其最近的整数取整。但是这有可能导致巨大的累计误差。在斯德哥尔摩的地图上，这种估计方法会导致在某两个地铁站之间的旅行时间的估计与实际时间出现一个将近15分钟的偏差。为了避免这个，你的程序需要选择一些相邻地铁站之间的旅行时间向上取整，其余的向下取整，从而使得点对之间最大的累计误差最小。', '　　输入包含多组数据。每组数据最开始是一个整数N(1≤N≤100)，为地铁站的个数。这N个地铁站用正整数1到N标记。接下来N-1行包含了三个整数a,b,t(1≤a,b≤n,1≤t≤300)，表示地铁站a和站b是相邻的，而且在它们之间旅行的时间花费是t秒。为了简化问题，忽略地铁在地铁站停留的时间。
　　输入以EOF结束。', '　　对于每组数据，输出数据组号（从1开始标号），然后输出对相邻地铁站之间的旅行时间进行舍入之后，两两地铁站之间旅行时间误差的最大值所能取到的最小值。具体参照样例所给定的格式。', '[{"input": "\n2  \n1 2 110  \n4  \n1 2 40  \n2 3 40  \n3 4 40  \n4  \n1 2 90  \n1 3 90  \n1 4 90  \n", "output": "\nCase 1: 10  \nCase 2: 40  \nCase 3: 60\n"}]', '5436afdf8af55ed3ac83595032f039d9', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);INSERT INTO problem_tag(name) VALUES('树');INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Subway Timing' limit 1),(select id from problem_tag where name='树' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Subway Timing' limit 1),(select id from problem_tag where name='动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Air Traffic Control', '　　为了避免空中相撞，大部分商业航班都被地面航空管制中心使用雷达跟踪其位置来监控。在这个问题中，你会被给予一组飞机和一组控制中心的信息，并计算出飞机是如何被控制中心监控的（这句话的意思参考输入描述：即计算恰好被K个控制中心监控的飞机数目），飞机的位置用(x,y)坐标表示，基于此题的目的，无视飞机的高度（海拔）。
　　一个给定的控制中心能够监控的飞机数量因设备和工作人员的改变而时刻变化。在任一时刻，每一个控制中心会尽可能地监控更多的飞机，它会按照如下优先级选择其监控的飞机：1.离这个控制中心欧几里得距离比较近的优于比较远的。2.若两架飞机到控制中心的距离相同，那么选择其中往北更远的(y坐标轴正方向)。3.如果两架飞机的距离和y坐标都相同，优先选择往东更远的（x坐标正方向）。（补充说明：也就是说在距离相同的情况下，先比较y坐标，y坐标大的优先级高，若y坐标依旧相同，x坐标大的优先级高。数据会保证没有任意两个飞机的坐标相同。）
　　在任意时刻，每一个控制中心都有一个圆形“控制范围”，其半径等于其所监控的最远的那架飞机的距离。所有在控制范围内的飞机都被该控制中心监控，但是在控制范围边界上的飞机可能或可能不被控制中心监控，这取决于控制中心的容量和以上列出的优先级。
　　你不会被告知控制中心的位置,取而代之的，对于每个控制中心，你会被告知它当前监控的飞机个数，以及其监控范围边界上的两点，用这些信息，你能计算出控制中心的位置，以及决定哪些飞机被其监控。如果数据包含多种可能的监控范围，你应该选择包含了靠北最远的那架飞机的，通过先选择靠北最远的再选择靠东最远的打破平局（——这段话的意思你可以这么认为：如果有多种可能的控制范围以及对应的控制中心位置满足输入要求，那么我们这么来判定：将飞机按照y坐标从大到小，y坐标相同的按照x从大到小排序，然后依次考虑，如果有架飞机在控制范围A内，而其不在控制范围B内，则我们会选择A而不是B。注意，若两个控制范围监控的飞机的集合相同，可以任意选择一个，因为这不影响答案）。
　　下面这张图展示了两个控制中心和四架飞机的情况。每个控制中心用一个圆形控制区域和这个区域中的两个点表示，用A和B标记。P1，P2，P3，P4标记了四架飞机。在这个例子中，飞机P1和P4都被一个单独的控制中心监视，而P3被两个控制中心监控，但P2却没有被任何一个控制中心监控。
', '　　输入包含多组测试数据，每个数据第一行包括两个正整数NP(0<NP<100)和NC(0<NC<10)，分别表示了飞机的个数和控制中心的个数。接下来NP行，每行两个浮点数表示一架飞机的(x,y)坐标。再接下来NC行，每行描述一个控制中心。首先是一个位于0到NP的正整数（包含0和NP），表示被该控制中心监控的飞机个数，然后是两对浮点数表示监控范围边界上的两个位置的(x,y)坐标（两个位置不会相同，而且也不会与飞机坐标重合）。注意：若两个点之间的距离小于0.00001，你应该将其视为一个点。
　　输入以两个0结束。', '　　对于每组数据，计算出被0个控制中心监控的飞机个数，被1个控制中心监控的飞机个数等等，直到被NC个控制中心监控的飞机个数。首先输出数据组号，然后接下来NC+1个数，序列中第ith数表示被i-1个控制中心监控的飞机个数。如果某个控制中心不存在相符合的监控范围，那么输出"Impossible"而不是相应的序列。使用样例中给定的输出格式，然后每组数据之后都要输出一个空行。
　　（关于输出格式，请注意冒号之后有两个空格，每个序列中每两个数之间有两个空格，序列的行末有两个空格，Impossible后没有空格，每组数据输出占两行。）', '[{"input": "\n4  2 \n3.0  0.0 \n0.0  0.0 \n1.6  2.8 \n2.0  1.0 \n2  1.0  2.0  2.0  0.0 \n2  2.0  2.0  4.0  2.0 \n2  1 \n0.0  0.5 \n0.0  -0.5 \n0   -1.0  0.0  1.0  0.0 \n0  0\n", "output": "Trial 1:  1  2  1\n\nTrial 2:  Impossible"}]', '2eabeaeb6517414c21ae36bc308b87bd', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);INSERT INTO problem_tag(name) VALUES('计算几何');INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Air Traffic Control' limit 1),(select id from problem_tag where name='计算几何' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Air Traffic Control' limit 1),(select id from problem_tag where name='模拟' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Tree-Lined Streets', '　　格林维尔的市议会最近对改善城市道路景观进行了投票。为了让城市增添一丝绿色，市议会决定在主要的大街两旁种树。由于想要初步预算这个城市改善计划的费用，市议会想要知道会种多少树。种树的时候有以下两条限制：
　　● 在一条大街上，每两棵树之间的距离至少为 50 米。这是为了给树提供充足的生长空间，同时把费用控制在合理的范围内。
　　●  出于安全考虑，树与它所在的大街上十字路口的距离应该不少于 25 米。这是为了保证司机能够轻松地看到其他靠近十字路口的人。交通安全决不能因为能见度降低而被削弱。

　　在这个项目中的所有大街都是笔直不弯曲的。

　　市议会想知道在这两个条件下能种的树有几棵。', '　　第一行一个整数 n，表示地图中大街的数量。接下来 n 行，每行四个整数 x1, y1, x2, y2，表示一条从 (x1, y1) 到 (x2,y2) 的线段，描述一条大街。每条大街长度都是正数，且每个端点只落在一条大街上。

　　对于一条大街，相邻的十字路口或端点的距离不会是 25 的倍数。更准确地，他们的距离与 25 的倍数的差不少于 0.001。在每个十字路口，恰好只会有两条大街交叉。', '　　输出在上述特定条件下最多能种的树的棵树。', '[{"input": "3\n0 1 121 1\n0 0 121 4\n0 4 121 0", "output": "7"}]', 'f876c02e84f4bc5f8b7cdf1fd9143ecb', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 7);INSERT INTO problem_tag(name) VALUES('暴力');INSERT INTO problem_tag(name) VALUES('几何');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Tree-Lined Streets' limit 1),(select id from problem_tag where name='暴力' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Tree-Lined Streets' limit 1),(select id from problem_tag where name='几何' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('矩阵相乘', '　　小明最近在为线性代数而头疼，线性代数确实很抽象（也很无聊），可惜他的老师正在讲这矩阵乘法这一段内容。
　　当然，小明上课打瞌睡也没问题，但线性代数的习题可是很可怕的。
　　小明希望你来帮他完成这个任务。

　　现在给你一个ai行aj列的矩阵和一个bi行bj列的矩阵，
　　要你求出他们相乘的积（当然也是矩阵）。
　　(输入数据保证aj=bi,不需要判断)', '　　输入文件共有ai+bi+2行，并且输入的所有数为整数（long long范围内）。
　　第1行：ai 和 aj
　　第2~ai+2行：矩阵a的所有元素
　　第ai+3行：bi 和 bj
　　第ai+3~ai+bi+3行：矩阵b的所有元素', '　　输出矩阵a和矩阵b的积（矩阵c)
　　（ai行bj列）', '[{"input": "2 2\n12 23\n45 56\n2 2\n78 89\n45 56", "output": "1971 2356\n6030 7141"}]', '425d957b4b6be46dcfa79bd927dcb1d2', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);INSERT INTO problem_tag(name) VALUES('线性代数');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='矩阵相乘' limit 1),(select id from problem_tag where name='线性代数' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('3-3求圆面积表面积体积', '　　接受用户输⼊的数值，输出以该值为半径的(1)圆面积，(2)球体表面积，(3)球体体积。pi 取值3.1415926536 ，结果保留10位小数，每一列占20个字符，左对齐。', '', '', '[{"input": "一个满足题目要求的输入范例。\n例：\n1", "output": "与上面的样例输入对应的输出。\n例：(第一行1是输入，第二行是输出)\n"}]', '6965b95e551cd6f99aad180f4bec73d9', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Trade on Verweggista', '　　自从Peter Stuyvesant和Abel Tasman的日子以后，荷兰商人已经周游世界来买卖商品。有一次在Verweggistan的贸易，但是它在很短的时间后就结束了。在读完这个故事之后你就明白了。
　　在当时Verweggistan是非常受欢迎的，因为世界上只有那个地方的人知道怎样制作一个“prul”（或者“prullen”，荷兰语中的复数形式），并且如今只有很少的人知道什么是一个“prul”。
　　“prul”是在工场里生产的。当一个“prul”做完的时候，它被包装在一个箱子里，然后放在之前生产的“prul”所装的箱子堆的上面。
　　价格取决于生产“prul”所需要的时间。如果一切顺利，一个“prul”的价格会是1或者2弗罗林，但是在一个恶劣的日子，价格会很容易地上升到15弗罗林或者更高。“prul”在品质上没有什么差别，所有的“prul”具有相同的价值。
　　在这些天，“prul”在荷兰的售价为每件10弗罗林。交通运输的费用是可以忽略的，因为“prul”无论如何都会作为额外的东西被装载到要航行的船上。当一个荷兰商人去Verweggistan时，他有一个明确的目的：买“prul”，在荷兰销售，并且最大化他的利润。不幸的是，Verweggistan地区对“prul”的交易方式使得这比某些人预想的更为复杂。
　　有人认为这很简单，商人会买那些最便宜的“prul”，而那些售价比10弗罗林高的“prul”会一直不能出售。不幸的是，Verweggistan的所有工场按照一种奇怪的顺序销售“prul”。堆顶的箱子里的“prul”会最先销售，然后销售从顶上开始数的第二个箱子里的“prul”，以此类推。所以即使第五个箱子里的“prul”是最便宜的，商人也必须买它上面四个箱子里的“prul”才能得到它。
　　正如你想象的那样，这使得商人通过购买正确的“prul”的组合来最大化他们的利润是相当难的。没有电脑帮助他们的优化，他们迅速彻底失去了交易“prul”的兴趣。
　　在这个问题中，给你对几个工场里箱子堆的描述。你必须根据上面所给的限制，计算出一个商人通过购买箱子堆中的“prul”可以获得的最大利润。另外，你必须确定他需要买多少个“prul”才能获得最大利润。', '　　输入文件包含多组测试数据。每个测试数据的第一行是一个整数w(1<=w<=50)，该测试数据中工场的数目。
　　接下来有w行，每行描述一个放“prul”的箱子堆。每行的第一个整数b(0<=b<=20)，表示堆中的箱子数。接下来是b个正整数，表示堆中“prul”的价格（单位为弗罗林）。输入中箱子的顺序是从顶到底。
　　输入数据终止于w=0，不再有后续的描述内容。', '　　对于每组测试数据，输出测试点的编号(1,2...)。然后输出两行，第一行输出商人可以获得的最大利润。第二行输出为获得最大利润商人需要买的“prul”数量。如果这个数量不是唯一确定的，按照升序输出可能的值。如果有超过10种可能的取值，只输出10个最小的取值。', '[{"input": "1\n6 12 3 10 7 16 5\n2\n5 7 3 11 9 10\n9 1 2 3 4 10 16 10 4 16\n0", "output": "Workyards 1\nMaximum profit is 8.\nNumber of pruls to buy: 4\nWorkyards 2\nMaximum profit is 40.\nNumber of pruls to buy: 6 7 8 9 10 12 13"}]', 'c90a35c491d55acd0e2564632a9d6b93', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 12);INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Trade on Verweggista' limit 1),(select id from problem_tag where name='动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('排列数', '　　0、1、2三个数字的全排列有六种，按照字母序排列如下：
　　012、021、102、120、201、210
　　输入一个数n
　　求0~9十个数的全排列中的第n个（第1个为0123456789）。', '　　一行，包含一个整数n', '　　一行，包含一组10个数字的全排列', '[{"input": "1", "output": "0123456789"}]', '1938e55dc156807d21322a54c4afa218', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('循环');INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='排列数' limit 1),(select id from problem_tag where name='循环' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='排列数' limit 1),(select id from problem_tag where name='枚举' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('周期字串', '　　右右喜欢听故事，但是右右的妈妈总是讲一些“从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，讲的什么呢？从前有座山……”这样循环的故事来搪塞右右。
　　我们定义，如果一个字符串是以一个或者一个以上的长度为k的重复字符串所连接成的，那么这个字符串就叫做周期为k的串。
　　例如:
　　字符串’abcabcabcabc’周期为3，因为它是由4个循环’abc’组成的。它同样是以6为周期（两个重复的’abcabc’）和以12为周期（一个循环’abcabcabcabc’）。
　　右右现在想给他的朋友大灰狼转述妈妈讲的故事，请帮他写一个程序，可以测定一个字符串的最小周期。', '　　一个最大长度为100的无空格的字符串。', '　　一个整数，表示输入的字符串的最小周期。', '[{"input": "Return0", "output": "7"}]', '9c9d0df6e6527187123c5582474660f5', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);INSERT INTO problem_tag(name) VALUES('字符串处理');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='周期字串' limit 1),(select id from problem_tag where name='字符串处理' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('金明的预算方案', '　　金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：
主件附件电脑打印机，扫描仪书柜图书书桌台灯，文具工作椅无
　　如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
　　设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j_1，j_2，……，j_k，则所求的总和为：
　　v[j_1]*w[j_1]+v[j_2]*w[j_2]+ …+v[j_k]*w[j_k]。（其中*为乘号）
　　请你帮助金明设计一个满足要求的购物单。', '　　输入文件budget.in 的第1行，为两个正整数，用一个空格隔开：
　　N  m
　　（其中N（<32000）表示总钱数，m（<60）为希望购买物品的个数。）
　　从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数
　　v  p  q
　　（其中v表示该物品的价格（v<10000），p表示该物品的重要度（1~5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q>0，表示该物品为附件，q是所属主件的编号）', '　　输出文件budget.out只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<200000）。', '[{"input": "1000 5\n800 2 0\n400 5 1\n300 5 1\n400 3 0\n500 2 0", "output": "2200"}]', 'd089522e22337ba937a5068d0375eb34', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 17);INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='金明的预算方案' limit 1),(select id from problem_tag where name='动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('三进制数位和', '　　给定L和R，你需要对于每一个6位三进制数（允许前导零），计算其每一个数位上的数字和，设其在十进制下为S。

　　一个三进制数被判断为合法，当且仅当S为质数，或者S属于区间[L,R]。

　　你的任务是给出合法三进制数的个数。', '　　一行两个非负整数L,R。', '　　一行一个非负整数表示答案。', '[{"input": "0 0", "output": "330"}]', '1abade6681bc09eb470d32cae7ea3227', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 12);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('条件判断');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='三进制数位和' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='三进制数位和' limit 1),(select id from problem_tag where name='条件判断' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('判断名次', '　　某场比赛过后，你想要知道A~E五个人的排名是什么，于是要求他们每个人说了一句话。（经典的开头……-_-!）得了第1名的人23，说了假话；得了第5名的人不好意思，也说了假话；为了使求解问题简单，第3名同样说了假话。（奇数名次说假话）', '　　共5行，各行依次表示A~E说的话。
　　每行包含一个形如“A>=3”的名次判断，即一个大写字母+关系运算符+一个数字，不包含空格。
　　大写字母A~E，关系运算<、<=、=、>=、>、!=，数字1~5。注意：等于是“=”不是“==”！', '　　可能有多解，请按照字典序输出排名序列，每个解一行
　　最后一行输出解的数量', '[{"input": "A=2\nD=5\nE>3\nA>2\nB!=1", "output": "ACDEB\nAECBD\nBADCE\nBCADE\nBDACE\nCEADB\nCEBDA\n7"}]', 'd9869fd672ac75009d9f8be97752b1e5', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);INSERT INTO problem_tag(name) VALUES('逻辑题,');INSERT INTO problem_tag(name) VALUES('第12周');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='判断名次' limit 1),(select id from problem_tag where name='逻辑题,' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='判断名次' limit 1),(select id from problem_tag where name='第12周' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Harvard', '　　“哈佛结构”是指一台拥有多个分散内存用于记录指令与数据的计算机。这个术语起源于“哈佛马克1号”计算机。它由IBM于1944年制造，用纸带记录指令，用继电器来储存数据。
　　一些最新的单片机使用了“哈佛结构”（当然没有用纸带和继电器）。数据是由“内存库”来组织，每个“内存库”拥有相同数量的数据。每一个访问数据的指令都由2个数控制。一个数a（非0即1）。如果a为0，那么访问的是0号“内存库”。如果a为1则访问BSR（bank select register “内存库”选择寄存器）中选择的“内存库”。另一个数f表示访问该“内存库”的第f个变量。我们假设每一个指令花费相同的时间运行。另外还有一个可以设定BSR值的命令。
　　举例来说，假设有4个“内存库”，每个“内存库”有8个字节。为了访问位置5（0号“内存库”第5个变量），我们有两种方法。第一种，使用指令a=0，f=5。第二种，先将BSR的值设为0，然后使用指令a=1，f=5。第一种方法更快，因为它不需要花费时间设置BSR。
　　现在假设（还是刚才的“内存库”）我们要访问位置20（2号“内存库”第4个变量）。现在只有1种方法能够访问。将BSR的值设为2（除非BSR原来就是2），然后用指令a=1，f=4。
　　一个程序是一个操作的序列，每个操作是：
　　●一个变量访问操作，写作Vi，i是一个正整数。
　　●一个循环操作，写作 Rn <program> E，n是一个正整数，<program>是一个任意的程序。这个操作等价于依次执行n遍<program>。
　　你的工作是决定一个程序最小的运行时间。更确切的说，给出“内存库”的个数和大小，需要执行的程序，输出为了执行这个程序最小的指令数（包括数据访问指令和设定BSR的指令）。为了完成这个，你必须设定一个变量到“内存库”的映射，使得这个程序运行时间最短，并且输出这个时间（也就是程序运行的指令数）。开始的时候BSR的值为undefined，直到一条命令显式的设定了它的值。', '　　每组输入包含一个case，两行。第一行两个整数b和s，1≤b≤13代表“内存库”的个数，1≤s≤13代表每个“内存库”的大小（即能储存的变量数）。第二行是一个非空程序，最多有1000个元素（每个Rn，Vi，E都算1个元素）。
　　保证：
　　在循环Rn中，循环次数1≤n≤10^6。
　　在循环Rn <program> E中, <program>非空。
　　在数据访问Vi中，1≤i≤min(b*s,13)。
　　程序访问变量的次数不超过10^12次。', '　　输出运行该程序最少需要的指令数。', '[{"input": "4 1\nV1 R2 V2 V4 R2 V1 E V3 E", "output": "17"}]', '1364629b2c7ea1de9d25a73652785b32', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 20);INSERT INTO problem_tag(name) VALUES('搜索');INSERT INTO problem_tag(name) VALUES('剪枝');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Harvard' limit 1),(select id from problem_tag where name='搜索' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Harvard' limit 1),(select id from problem_tag where name='剪枝' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('The Sky is the Limit', '　　Banff城雇用了一家广告公司来提升这座城市对潜在的游客的吸引力。其中一个计划中的口号声称延伸在这座城市周围的山脉组成了加拿大最美丽的天际线。但是加拿大消费者保护协会认为“最美丽的天际线”是一种主观的，无法证实的声称，而且可能因此让人误解。
　　然后那个广告公司就想出了一个口号“Banff——加拿大最长的天际线”。虽然没有那么引人注意，但这是有希望能证实的，而且这样就能被加拿大复杂的广告法律所接受了。
　　这就是你要介入的原因。广告公司需要的是一个能确定天际线的长度的程序。把每座山脉看作是一个二维的上面两条边长度相等的三角形。一条天际线是一座或多座山脉的轮廓。天际线的长度就是轮廓的总长度。下面的左图显示了三座山脉。右图显示了（用黑线）天际线和（用虚线）山脉上面的边中不是天际线的部分。注意位于山脉之间的地平线部分不在天际线考虑的范围内。
', '　　第一行包含一个正整数N，表示范围内的山脉数。接下来N行每行用三个整数X,H,B来描述每一座山脉，分别表示山脉的最高点到某个固定的点的水平距离，山脉的垂直高度和山脉的底边的宽度。每座山脉的底部在同一条水平线上。数据满足N≤100，H＞0而且B＞0。', '　　输出只有一行，即天际线的长度。输出那个长度四舍五入后的结果。', '[{"input": "3\n20 30 35\n37 24 29\n60 20 13", "output": "138"}]', '43402e97aa5656ba75456bf4064520b8', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 17);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('几何');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='The Sky is the Limit' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='The Sky is the Limit' limit 1),(select id from problem_tag where name='几何' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('5-3日历', '　　已知2007年1月1日为星期一。设计一函数按照下述格式打印2007年以后（含）某年某月的日历，2007年以前的拒绝打印。为完成此函数，设计必要的辅助函数也是必要的。', '', '', '[{"input": "一个满足题目要求的输入范例。\n例：\n\n2050 3", "output": "与上面的样例输入对应的输出。\n例：\n\n\n"}]', '355b7e914650db7a54761ad451405c46', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Petri Net Simulation', '　　一个Petri网是一个计算模型，用来说明并发事件。每个Petri网包含一些库所（被表示成圆圈），变迁（被表示成黑色的矩形），和一些有向边，用来连接库所到变迁，和变迁到库所。每个库所能够包含0个或多个令牌（被表示成黑点）。
　　这里有2个例子：




　　在上面的第一个Petri网中，有2个库所（P1 和 P2）和2个变迁（T1 和 T2）。P1初始有1个令牌。P2没有令牌。P1是变迁T1的输入库所，P2是T1的输出库所。在第二个例子中，有3个库所和3个变迁，P1有3个令牌。T2有2个输入库所，2个都是P2。

　　一个Petri网的操作

　　每个Petri网的变迁要么被允许，要么不被允许。一个变迁被允许当且仅当每个输入库所都至少有1个令牌。任何被允许的变迁可以发生。如果有多个变迁被允许，任何一个都可能发生。当一个变迁发生时，每个输入库所都会移除1个令牌，每个输出库所都会增加1个令牌。这会有效地利用原子能来完成，作为一个事件。如果没有一个变迁被允许，这个Petri网就被认为是死的。

　　最上面那个例子，只有T1是被允许的。当它发生时，会从P1移除1个令牌，给P2增加1个令牌。然后T2就被允许了。当它发生时，会从P2移除1个令牌，给P1增加1个令牌。显然，这个Petri网将会永远重复这个循环。

　　下面那个例子更加有趣。T1被允许然后发生，有效地移动1个令牌给P2。在这个时候，T1仍然是唯一被允许的变迁（T2被允许需要P2有2个令牌）。T1再次发生，在P1剩下1个令牌，P2中有2个令牌。现在，T1和T2都被允许。假设T2发生，从P2移除2个令牌，给P3增加1个令牌。现在T1和T3都被允许。直到没有变迁被允许，你应该能看到在9次变迁发生后，在P2仅留下1个令牌。（注意到，如果当T1和T2都被允许的时候，T1代替了T2发生，这个结果也同样是在9次变迁发生后。）

　　在这个问题中，你将会被给出1个或多个Petri网的描述。对于每个描述，你将要模拟NF（0 < NF < 1000）次变迁的发生，然后输出留在库所里的令牌数量。如果这个Petri网在NF次变迁发生之前就死了，你将按事实输出。', '　　每个Petri网的描述首先会包含一个整数NP（0 < NP < 100），紧接着有NP个整数分别表示编号为1，2，…，NP的库所初始有多个个令牌。接着会有一个整数NT（0 < NT < 100）表示变迁的数量。然后，对于每个变迁（编号为1，2，…，NT）将会有一个以0结尾的整数序列。序列中的负数代表输入库所，所以数字-n代表有一个输入库所在n。序列中的正数代表输出库所，所以数字p代表有一个输出库所在p。每个库所至少有一个输入库所，至少有一个输出库所。最后，在NT个变迁的描述之后，会有一个整数代表你至多要模拟变迁发生的次数，NF。输入会包含一个或多个Petri网的描述，最后会有一个0。', '　　对于每个Petri网的描述，输出三行。第一行输出是第几组数据（从1开始连续编号）和是否有NF次变迁发生。如果有，输出这个Petri网在NF次变迁发生后仍然活着。否则输出这个Petri网已经死了和变迁发生的次数。两种情况下，在第二行都输出在模拟结束后，包含1个或多个令牌的库所的编号，和每个这种库所含有的令牌数量。输出的序列按编号递增。每组数据的第三行都应该是空行。
　　输入数据将会被选择来保证正确输出的唯一性。', '[{"input": "2\n1 0\n2\n-1 2 0\n-2 1 0\n100\n3\n3 0 0\n3\n-1 2 0\n-2 -2 3 0\n-3 1 0\n100\n0", "output": "Case 1: still live after 100 transitions\nPlaces with tokens: 1 (1)\n\nCase 2: dead after 9 transitions\nPlaces with tokens: 2 (1)"}]', '4c4d30ce18ec9298976dc65f926b1cef', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 18);INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Petri Net Simulation' limit 1),(select id from problem_tag where name='模拟' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('合并石子', '　　在一条直线上有n堆石子，每堆有一定的数量，每次可以将两堆相邻的石子合并，合并后放在两堆的中间位置，合并的费用为两堆石子的总数。求把所有石子合并成一堆的最小花费。', '　　输入第一行包含一个整数n，表示石子的堆数。
　　接下来一行，包含n个整数，按顺序给出每堆石子的大小 。', '　　输出一个整数，表示合并的最小花费。', '[{"input": "5\n1 2 3 4 5", "output": "33"}]', '30db09975b78076147c74d0aeeed3e85', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 17);INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tag(name) VALUES('DP');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='合并石子' limit 1),(select id from problem_tag where name='动态规划' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='合并石子' limit 1),(select id from problem_tag where name='DP' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('c++_ch02_04', '　　输出1~100间的质数并显示出来。注意1不是质数。', '', '　　每行输出一个质数。
　　2
　　3
　　...
　　97', '[]', '9f057cb0bdef1b81f48a0ba03d87fe01', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 5);INSERT INTO problem_tag(name) VALUES('循环，输出');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='c++_ch02_04' limit 1),(select id from problem_tag where name='循环，输出' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Lots of Sunlight', '　　公寓建设管理公司（Apartment Construction Management, 简称ACM）在上海郊区新建了几栋高层公寓楼。由于经济增长极为迅速，ACM期望通过出租房屋获得客观的利润。ACM打广告宣称他们的公寓比附近其他的公寓都要好，因为他们的公寓采光更好。没有其他的建筑物阻挡阳光直射到ACM的公寓楼上。
　　ACM想要证明自己的广告没有虚假成分，于是他们决定告诉潜在住户们每栋楼的采光究竟怎样。为了给消费者们有代表性的数据，公司决定将2005年4月5日的阳光直射时长写入广告。在那一天，上海于早上5点37分日出，于下午6点17分日落。



　　如上图所示，公寓楼从东至西排列，每栋楼有若干层，每层有一间公寓。公寓门牌号的后两位代表楼栋编号，最东侧的楼编号为01，从东至西编号递增。门牌号的其他所有位则代表楼层，1为一层，2为二层，以此类推。
　　太阳从东方升起，以恒定角速度划过天空，然后从西方落下。阴影仅由楼房投射出（也即，每栋楼可以投影到一栋或者多栋其他的楼房上）。当一间公寓的整块东侧或西侧外墙被太阳直射，或者当太阳处于公寓正上方时，我们就认为公寓受到太阳直射。', '　　输入含有若干组测试数据。一组测试数据首先含有一行，包括一个整数n，代表公寓楼的数量。接下来一行有两个整数w和h，分别代表一间公寓的宽度（东-西方向）和高度，单位为米。接下来一行有2n-1个整数，记作m(1), d(1), m(2), d(2), ... , d(n-1),m(n)。m(i)为编号为i的公寓楼的层数，d(i)为编号为i和i+1的公寓楼之间的距离，单位为米。
　　接下来的一行包含若干整数，以0结尾。每个整数代表求编号为这个整数的公寓的太阳直射时间。输入的最后一行仅包含一个整数0，你不需要处理这一行。
　　最多含有10组测试数据。', '　　对于每组数据，输出数据组数的编号。然后对于每个询问，用24小时格式输出太阳直射时间的起止时刻。所有时间向下取整到秒。允许输出与答案有最大1秒的误差。如果输入中含有不存在的公寓的编号，请将其指出。请按照样例输出中的格式输出。', '[{"input": "3\n6 4\n5 6 3 3 4\n302 401 601 303 0\n4\n5 3\n4 5 7 8 5 4 3\n101 302 503 0\n0", "output": "Apartment Complex: 1\nApartment 302: 10:04:50 - 13:23:47\nApartment 401: 05:37:00 - 17:13:57\nApartment 601: Does not exist\nApartment 303: 09:21:19 - 18:17:00\nApartment Complex: 2\nApartment 101: 05:37:00 - 12:53:32\nApartment 302: 09:08:55 - 14:52:47\nApartment 503: 09:01:12 - 18:17:00"}]', 'ec1c5d5cd42afeb23a26f18daa116957', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 18);INSERT INTO problem_tag(name) VALUES('计算几何');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Lots of Sunlight' limit 1),(select id from problem_tag where name='计算几何' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Tunnels', '　　一个间谍从你的陷阱中逃出来了，干掉了你的警卫，并且带走了你毁灭世界的计划。你的糟糕的行动由此受到了威胁。现在你需要在他逃出基地之前抓到他。
　　你的基地由一系列房间和连接它们的双向隧道组成，隧道只在房间处相交。每个房间都配有监控摄像，使你能在任意时刻了解间谍所处的位置。另外，每条隧道里都装有遥控炸药，触发后可以永久毁坏该隧道。间谍在隧道中移动极快，因此你不可能把他困在炸毁的一条隧道中，但你可以炸毁一些隧道，使他无法逃出基地。
　　显然，间谍不可能逃出基地。所以你的目标是在困住他的同时炸毁最少的隧道，因为之后的重建非常昂贵。找到一种策略，使得在最坏情况下需要炸毁的隧道数最小。', '　　输入包含多组数据。每组数据的第一行包含两个整数R, T，分别表示房间的隧道的数量。接下来T行，每行两个整数a, b(0 <= a, b <= R)，表示隧道两端的房间编号。形如"0 x"或"x 0"的输入表示联通房间x和基地外部的隧道。
　　间谍从1出发，你需要阻止他到达点0（基地外部）。', '　　对第i组输入，输出"Case $i: ${ans}\n\n"，其中${ans}表示对应的答案。
　　参见样例输出的格式。', '[{"input": "4 6\n1 2\n1 3\n2 4\n3 4\n4 0\n4 0\n4 6\n1 2\n1 3\n1 4\n2 0\n3 0\n4 0\n0 0", "output": "Case 1: 2\n\nCase 2: 2\n\n如你所见, 输出的最后有一个空行。"}]', 'f250601861319767a8ec77d3d2ae1d8b', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 5);INSERT INTO problem_tag(name) VALUES('网络流');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Tunnels' limit 1),(select id from problem_tag where name='网络流' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('三角形面积', '　　由三角形的三边长，求其面积。
　　提示：由三角形的三边a,b,c求面积可以用如下的公式：
　　s=（a+b+c）/2
　　面积=', '　　由空格分开的三个整数。', '　　一个实数，保留两位小数。', '[{"input": "3 4 5", "output": "6.00"}]', 'c13cd3723b86a8aa4562865cfc9c1ac9', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 20);INSERT INTO problem_tag(name) VALUES('a基础');INSERT INTO problem_tag(name) VALUES('顺序');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='三角形面积' limit 1),(select id from problem_tag where name='a基础' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='三角形面积' limit 1),(select id from problem_tag where name='顺序' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('求最大值', '　　给n个有序整数对ai bi，你需要选择一些整数对 使得所有你选定的数的ai+bi的和最大。并且要求你选定的数对的ai之和非负，bi之和非负。', '　　输入的第一行为n，数对的个数
　　以下n行每行两个整数 ai bi', '　　输出你选定的数对的ai+bi之和', '[{"input": "5\n-403 -625\n-847 901\n-624 -708\n-293 413\n886 709", "output": "1715"}]', 'ba260d509e7fc8bb2553739412f6a4e6', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='求最大值' limit 1),(select id from problem_tag where name='动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('最长公共子序列', '　　给定两个字符串，寻找这两个字串之间的最长公共子序列。', '　　输入两行，分别包含一个字符串，仅含有小写字母。', '　　最长公共子序列的长度。', '[{"input": "abcdgh\naedfhb", "output": "3"}]', '6089763161d26c3b18c053c6f3de2226', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 3);INSERT INTO problem_tag(name) VALUES('DP');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='最长公共子序列' limit 1),(select id from problem_tag where name='DP' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('盾神与条状项链', '　　有一天，盾神捡到了好多好多五颜六色的珠子！他心想这些珠子这么漂亮，可以做成一条项链然后送给他心仪的女生~于是他用其中一些珠子做成了长度为n的项链。当他准备把项链首尾相接的时候，土方进来了。
　　“哇这么恶心的项链你也做得出来！！！”
　　盾神自知审美不是他的长项，于是他很谦虚地请教土方，怎么才能把项链做得漂亮。
　　“这个嘛~首先你要在这里加上一个这种颜色的珠子，然后在这里去掉这个珠子，然后……，最后你看看是不是漂亮很多咧~”土方一下子说出了m个修改步骤。
　　盾神觉得这个用人工做太麻烦了，于是交给了你。', '　　第一行两个数，分别为n，m。
　　第二行n个数，表示盾神一开始的项链。第i个数表示第i颗珠子的颜色。
　　接下来m行，为以下形式之一：
　　ADD P Q：表示在颜色为P的珠子前面加上一个颜色为Q的珠子。
　　DEL P：表示把颜色为P的珠子去掉，如果它不在端点处，则需要把它旁边的两颗珠子连起来。例如某时刻项链状态为1 4 5 8，则执行DEL 4会变成1 5 8，执行DEL 1会变成4 5 8。
　　输入保证在每次操作之前，项链有颜色为P的珠子，且任意时刻珠子颜色互不相同。', '　　第一行为一个数len，为做完所有操作后，项链的长度。
　　第二行len个数，表示此时项链的状态。第i个数表示第i颗珠子的颜色。', '[{"input": "10 5\n1 2 3 4 5 6 7 8 9 10\nDEL 5\nADD 7 5\nDEL 10\nADD 4 20\nADD 20 12", "output": "11\n1 2 3 12 20 4 6 5 7 8 9"}]', '471022a10430d6efdf03949b917956fa', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 3);INSERT INTO problem_tag(name) VALUES('链表');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='盾神与条状项链' limit 1),(select id from problem_tag where name='链表' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('9-1九宫格', '　　九宫格。输入1-9这9个数字的一种任意排序，构成3*3二维数组。如果每行、每列以及对角线之和都相等，打印1。否则打印0。', '', '', '[]', 'd0612574860ffdd05e53506d4e650b59', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 10);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('矩阵翻转', '
Ciel有一个N*N的矩阵，每个格子里都有一个整数。
N是一个奇数，设X = (N+1)/2。Ciel每次都可以做这样的一次操作：他从矩阵选出一个X*X的子矩阵，并将这个子矩阵中的所有整数都乘以-1。
现在问你经过一些操作之后，矩阵中所有数的和最大可以为多少。
', '
第一行为一个正整数N。
接下来N行每行有N个整数，表示初始矩阵中的数字。每个数的绝对值不超过1000。
', '
	输出一个整数，表示操作后矩阵中所有数之和的最大值。
', '[{"input": "\n3\n-1 -1 1\n-1 1 -1\n1 -1 -1\n", "output": "\n9\n\t"}]', '19d9ed9925d1befb0f76d7fc60f07e29', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 17);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('贪心');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='矩阵翻转' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='矩阵翻转' limit 1),(select id from problem_tag where name='贪心' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('12-1三角形', '　　为二维空间中的点设计一个结构体，在此基础上为三角形设计一个结构体。分别设计独立的函数计算三角形的周长、面积、中心和重心。输入三个点，输出这三个点构成的三角形的周长、面积、外心和重心。结果保留小数点后2位数字。', '', '', '[]', 'ede9223656d81e6ec93e74781ad991f7', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 20);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('上帝造题五分钟', '　　第一分钟，上帝说：要有题。于是就有了L，Y，M，C
　　第二分钟，LYC说：要有向量。于是就有了长度为n写满随机整数的向量
　　第三分钟，YUHCH说：要有查询。于是就有了Q个查询，查询向量的一段区间内元素的最小值
　　第四分钟，MZC说：要有限。于是就有了数据范围
　　第五分钟，CS说：要有做题的。说完众神一哄而散，留你来收拾此题', '　　第一行两个正整数n和Q，表示向量长度和查询个数
　　接下来一行n个整数，依次对应向量中元素：a[0]，a[1]，…，a[n-1]
　　接下来Q行，每行两个正整数lo，hi，表示查询区间[lo, hi]中的最小值，即min(a[lo],a[lo+1],…,a[hi])。', '　　共Q行，依次对应每个查询的结果，即向量在对应查询区间中的最小值。', '[{"input": "7 4\n1 -1 -4 8 1 2 -7\n0 0\n1 3\n4 5\n0 6", "output": "1\n-4\n1\n-7"}]', '7bc55abc9170251e9d0034db748f62ed', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 18);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('金属采集', '
人类在火星上发现了一种新的金属！这些金属分布在一些奇怪的地方，不妨叫它节点好了。一些节点之间有道路相连，所有的节点和道路形成了一棵树。一共有 n 个节点，这些节点被编号为 1~n 。人类将 k 个机器人送上了火星，目的是采集这些金属。这些机器人都被送到了一个指定的着落点， S 号节点。每个机器人在着落之后，必须沿着道路行走。当机器人到达一个节点时，它会采集这个节点蕴藏的所有金属矿。当机器人完成自己的任务之后，可以从任意一个节点返回地球。当然，回到地球的机器人就无法再到火星去了。我们已经提前测量出了每条道路的信息，包括它的两个端点 x 和 y，以及通过这条道路需要花费的能量 w 。我们想花费尽量少的能量采集所有节点的金属，这个任务就交给你了。
', '
第一行包含三个整数 n, S 和 k ，分别代表节点个数、着落点编号，和机器人个数。
接下来一共 n-1 行，每行描述一条道路。一行含有三个整数 x, y 和 w ，代表在 x 号节点和 y 号节点之间有一条道路，通过需要花费 w 个单位的能量。所有道路都可以双向通行。
', '
	输出一个整数，代表采集所有节点的金属所需要的最少能量。
', '[{"input": "\n6 1 3\n1 2 1\n2 3 1\n2 4 1000\n2 5 1000\n1 6 1000\n", "output": "\n3004\n\t"}]', '6ee5aa5deb3c869cc558ab5cce281f3a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);INSERT INTO problem_tag(name) VALUES('树形动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='金属采集' limit 1),(select id from problem_tag where name='树形动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('最小方差生成树', '
    给定带权无向图，求出一颗方差最小的生成树。
', '
   输入多组测试数据。第一行为N,M，依次是点数和边数。接下来M行，每行三个整数U,V,W，代表连接U,V的边，和权值W。保证图连通。n=m=0标志着测试文件的结束。 
 ', '
    对于每组数据，输出最小方差，四舍五入到0.01。输出格式按照样例。
', '[{"input": "\n4 5\n1 2 1\n2 3 2\n3 4 2\n4 1 1\n2 4 3\n4 6\n1 2 1\n2 3 2\n3 4 3\n4 1 1\n2 4 3\n1 3 3\n0 0\n\n", "output": "\nCase 1: 0.22\nCase 2: 0.00\n\t"}]', '412062cf058d35a2dc90671f5f773197', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);INSERT INTO problem_tag(name) VALUES('最小生成树');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='最小方差生成树' limit 1),(select id from problem_tag where name='最小生成树' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('最大乘积', '　　对于n个数，从中取出m个数，如何取使得这m个数的乘积最大呢？', '　　第一行一个数表示数据组数
　　每组输入数据共2行：
　　第1行给出总共的数字的个数n和要取的数的个数m，1<=n<=m<=15，
　　第2行依次给出这n个数，其中每个数字的范围满足:a[i]的绝对值小于等于4。', '　　每组数据输出1行，为最大的乘积。', '[{"input": "1\n5 5\n1 2 3 4 2", "output": "\n48 \n"}]', 'db8adece0a3d1bdfbf45b718c0fdaa67', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('01背包', '　　给定N个物品,每个物品有一个重量W和一个价值V.你有一个能装M重量的背包.问怎么装使得所装价值最大.每个物品只有一个.', '　　输入的第一行包含两个整数n, m，分别表示物品的个数和背包能装重量。
　　以后N行每行两个数Wi和Vi,表示物品的重量和价值', '　　输出1行，包含一个整数，表示最大价值。', '[{"input": "3 5\n2 3\n3 5\n4 7", "output": "8"}]', '7e65bdffc35a3a1f9518b3723d869801', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 19);INSERT INTO problem_tag(name) VALUES('小教员');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='01背包' limit 1),(select id from problem_tag where name='小教员' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('排序', '　　编写一个程序，输入3个整数，然后程序将对这三个整数按照从大到小进行排列。
　　输入格式：输入只有一行，即三个整数，中间用空格隔开。
　　输出格式：输出只有一行，即排序后的结果。
　　输入输出样例', '', '', '[{"input": "9 2 30", "output": "30 9 2"}]', '3e3fcdfcb01c858288181825b6a08b9a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);INSERT INTO problem_tag(name) VALUES('组合');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='排序' limit 1),(select id from problem_tag where name='组合' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Glenbow Museum', '　　卡城著名的格林堡博物馆是加拿大西部最大的博物馆，展品涵盖了艺术、文化史以及矿物学。如今一个全新的展区正在被布置，它是专门为你这样杰出的程序猿（媛）打造的。不幸的是，由于空间不足，博物馆打算建造一栋新的建筑来重新安置这个展区。
　　新的建筑的尺寸和容量将不同于原始的建筑，但是所有楼层的设计都是直角多边形。一个直角多边形是内角均为90°或270°的多边形。如果我们记90°角为R（Right）、270°角为O（Obtuse），那么一个只包含R和O的字符串能够粗略的表示一个直角多边形。比如，一个矩形（图形1）就是最简单的直角多边形，它能够用RRRR来描述（内角按逆时针排列，起始角任意）。同样地，一个十字形直角多边形（图形2）能够用RRORRORRORRO、RORRORRORROR或者ORRORRORRORR来描述。这些序列被称为角序列。





　　当然，一个角序列不一定能完全对应一个形状的多边形，因为它没有说明边长。并且一个角序列不一定能描述一个合法的直角多边形（比如RRROR）。
　　为了把事情搞得更麻烦，博物馆并不接受所有的楼层设计。一个博物馆保存了许多价值连城的物品，它们必须要被看守着。出于对成本的考虑，一个楼层最多只能有一个保安。所以只有满足以下要求的楼层设计能被接受：存在一个地点使得一个保安能监视到整个楼层。因此一个角序列能被接受，当且仅当它描述了一个能够被接受的多边形。注意图形2的十字形直角多边形能够被站在中心的保安完全监视，所以它是被接受的，因此角序列RRORRORRORRO是被接受的，即使它也能够描述其他不能被一个保安监视的多边形。
　　请帮助新建筑的设计师确定有多少给定长度的能够被接受的角序列。', '　　输入文件包含多组测试数据。每组数据一行，包含一个正整数 L (1 <= L <= 1000)，表示给定的角序列长度。
　　输入文件以仅包含0的一行结束。', '　　对于每一组数据，输出一行，包含测试数据编号（从1开始），之后为给定长度的被接受的角序列的个数。具体格式参考样例输出。', '[{"input": "4\n6\n0", "output": "Case 1: 1\nCase 2: 6"}]', '7d30c92fe8c242d9f4ba82684739ab7f', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 16);INSERT INTO problem_tag(name) VALUES('数学');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Glenbow Museum' limit 1),(select id from problem_tag where name='数学' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('4-2找公倍数', '　　这里写问题描述。
　　打印出1-1000所有11和17的公倍数。', '', '', '[{"input": "一个满足题目要求的输入范例。\n例：\n无", "output": "与上面的样例输入对应的输出。\n例：\n"}]', '8278192ffa9edb6d6675a71137fd337f', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 19);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('C*++ Calculations', '　　C*++语言和C++语言非常相似，然而C*++的程序有时会出现意想不到的结果。比如像这样的算术表达式：
　　表达式=基本式 / 表达式+基本式 / 表达式-基本式
　　基本式=增量 / 系数*增量
　　增量=a++ / ++a
　　系数=0/1/2/……/1000
　　如“5*a++-3*++a+a++”是合法的C*++表达式。
　　计算这样的表达式的值的方法：首先是每个基本式进行计算，然后按照正常的算术运算法则计算。如果一个基本式包含“a++”，则先进行乘法运算再使变量a权值+1；如果一个基本式包含“++a”，则先使变量a权值+1再进行乘法运算。
　　然而基本式可以按任意顺序计算，这就是为什么计算结果是完全无法预料的。
　　你的任务就是去找到最大的可能结果。

　　第一行，一个整数n，表示变量a的初始值。
　　第二行，一个合法的C*++表达式。

　　共一行，一个整数ans，表示最大可能结果。', '　　input 1:
　　1
　　5*a++-3*++a+a++
　　input 2:
　　3
　　a+++++a', '　　output 1:
　　11
　　output 2:
　　8', '[]', 'bf33b446230d6c74e4787bbcb42dd381', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('字符串处理');INSERT INTO problem_tag(name) VALUES('');INSERT INTO problem_tag(name) VALUES('贪心');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='C*++ Calculations' limit 1),(select id from problem_tag where name='字符串处理' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='C*++ Calculations' limit 1),(select id from problem_tag where name='' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='C*++ Calculations' limit 1),(select id from problem_tag where name='贪心' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('送分啦', '　　这题想得分吗？想，请输出“yes”；不想，请输出“no”。', '', '　　输出包括一行，为“yes”或“no”。', '[]', 'd3b306c8b4049fc6c53746c9a15fecaf', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('To Add or to Multipl', '　　工业计算机处理器公司为顾客量身定做了非常快速、用于专门目的的处理单元。a-C-m系列的处理器（比如1-C-2和5-C-3）的指令集只有两种操作：
　　•	A 数值加a
　　•	M 数值乘m
　　处理器接收一个整数，执行一个A和M的指令序列（即程序）来修改输入，然后输出结果。举个例子，1-C-2处理器执行程序AAAM处理输入2返回输出10（计算过程是2→3→4→5→10）,然而5-C-3处理器用相同的程序和输入返回51（2→7→12→17→51）。
　　你是一个被指定做一个顶级秘密项目的a-C-m程序员。这意味着你不会被告知你的程序执行的精确输入。但会得到四个特别的值p，q，r，s，以及下列条件
　　1、输入保证是一个在p、q之间的数
　　2、输出必须是一个在r，s之间的数。
　　给你一个a-C-m处理器和p，q，r，s这四个数。你的工作是构想最短的a-C-m程序，使得任意任意x保证p≤x≤q，返回一个输出y使得r≤y≤s。如果有多个最短的程序，选择字典序最小的，而一个程序即是由A和M组成的字符串。', '　　输入包含多组数据。每组数据在一行中给你6个整数a，m，p，q，r，s，每个就像上面描述的一样。
　　末行输入6个0作为结束。', '　　对于每组数据，在你的程序前输出数据的编号，程序即像上面描述的一样。输出单词“empty”，如果最好的程序没有操作。输出单词“impossible”如果没有程序满足具体要求。
　　输出一个用空格分隔的字符串序列，任两个相邻的字符串形式分别为“nA”和“nM”，n>0。前者表示n个连续的操作A，后者表示n个连续的操作M。', '[{"input": "1 2 2 3 10 20\n1 3 2 3 22 33\n3 2 2 3 4 5\n5 3 2 3 2 3\n0 0 0 0 0 0", "output": "Case 1: 1A 2M\nCase 2: 1M 2A 1M\nCase 3: impossible\nCase 4: empty"}]', 'a5aed989155e16574c193d2a114586ad', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 10);INSERT INTO problem_tag(name) VALUES('数学');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='To Add or to Multipl' limit 1),(select id from problem_tag where name='数学' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Multithreading', '　　现有如下一个算法：
　　repeat ni times
　　yi := y
　　y  := yi+1
　　end repeat
　　令n[1]为你需要算加法的第一个数字，n[2]为第二个，...n[N]为第N个数字（N为需要算加法的数字个数），
　　并令y初始值为0，先令i=1运行这个算法（如上所示，重复n[i]次），然后令i=2运行这个算法。。直到i=N。注意y值一直不要清零。最后y的值就是你需要的加法答案。
　　你想知道，有没有某种运算顺序能使答案等于W。
　　一个循环中的全部语句，是不能改变在总的语句排列中的相对顺序的。
　　（这里的第i个循环是指这n[i]*2条语句。就是你把属于第i个循环的语句抽出来看，它们需要按照原顺序排列。在你没有运行完这个循环的最靠前一条未完成的 语句的时候，你是不能跳过它先去完成这个循环后面的语句的。你能做的仅是把若干个循环按照你所规定的顺序“归并”起来。）
　　举个例子，n[1]= 2 ,n[2]=1, W=1.一种可行的运算顺序是“2 1 1 1 1 2”，数字为几表示运行第几个算法的下一条语句（你可以看到”1”出现了4次，是因为n[1]=2即循环两次，而每次循环里面有两条语句，所以2*2=4次）


y值
y[1] 值
y[2] 值
执行0条语句过后
0
0
0
执行1条过后(y[2]=y)
0
0
0
执行2条过后(y[1]=y)
0
0
0
执行3条过后(y=y[1]+1)
1
0
0
执行4条过后(y[1]=y)
1
1
0
执行5条过后(y=y[1]+1)
2
1
0
执行6条过后(y=y[2]+1)
1
1
0
 

 　　可以看到，最后y值变成了1，也就完成了我们的任务。', '　　第一行你会得到用空格分开的两个整数N(1<=N<=100)和W(-10^9<=W<=10^9)，（N为需要算加法的数字个数，W是你希望算出的数）。
　　第二行你会得到n个整数n[i] (1<=n[i]<=1000).', '　　第一行您应该输出Yes(若能以某种顺序使得这个算法得出W的值) 或No。
　　如果第一行是No，接下来就不用继续输出了。
　　如果是Yes, 请在第2行输出2*sigma(n[i])个用空格隔开的数，表示任意一种满足条件的运算顺序。', '[{"input": "3 6\n1 2 3", "output": "Yes\n1 1 2 2 2 2 3 3 3 3 3 3"}]', '7b421fe5bc2abbe9fbf94eb371d1a8ae', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 4);INSERT INTO problem_tag(name) VALUES('构造');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Multithreading' limit 1),(select id from problem_tag where name='构造' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Castles', '　　战争在世界历史中扮演了重要角色。与现代战争不同，中世纪的军队主要忙于夺取和控制贵族的私有设防住宅——城堡。一个进攻军队的规模是军队夺取和控制这些建筑杰作的能力的重要影响因素。

　　夺取城堡会使用最少需要的士兵数量。一些士兵在进攻中会死去。夺取城堡后，一些士兵被要求留在城堡里防卫其他军队的进攻。当然，留守的士兵数量根据不同的城堡而不同。军队指挥官有义务来考虑进攻成功需要的士兵数量。例如，图中有5个城堡，右下角的城堡需要至少20个士兵才能进攻成功，没有人在进攻中会死去，军队前进后10个士兵必须留在城堡里。
　　你需要确定一个军队夺取和控制一个特定地区的所有城堡所需要的最小规模。出于安全因素，该地区的任意一对城堡之间有且仅有一条路径。移动到相邻的未夺取城堡就会发动对该城堡的进攻。任何城堡都可以作为第一个被进攻的城堡，不用管军队是怎么到那里的。一旦某个城堡被夺取，要求的士兵数量被留在城堡里保卫它，若还有未夺取城堡，则军队剩余的人继续前进夺取其他城堡。军队可以安全到达已被夺取的城堡的相邻城堡。但由于被进攻的潜在可能，军队在同一方向上经过同一条路最多一次。', '　　第一行包含一个整数n，表示该地区的城堡数。
　　接下来n行每行包含三个整数a_i, m_i和g_i，表示成功夺取城堡i需要的最少士兵数量，在进攻中会死去的士兵数量和必须留守的士兵数量。
　　接下来n - 1行每行包含两个整数x_i和y_i，表示一条直接连接城堡x_i和城堡y_i的道路。', '　　一行包含一个整数，表示夺取和控制该地区的所有城堡所需要的最少士兵数量。', '[{"input": "5\n10 5 10\n20 10 5\n10 10 5\n5 5 5\n20 0 10\n1 2\n1 3\n1 4\n3 5", "output": "65"}]', '94ae3f71e97fc397261bdf51c670e658', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 17);INSERT INTO problem_tag(name) VALUES('树形动态规划');INSERT INTO problem_tag(name) VALUES('贪心');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Castles' limit 1),(select id from problem_tag where name='树形动态规划' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Castles' limit 1),(select id from problem_tag where name='贪心' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('最短路', '
给定一个n个顶点，m条边的有向图（其中某些边权可能为负，但保证没有负环）。请你计算从1号点到其他点的最短路（顶点从1到n编号）。
', '
第一行两个整数n, m。
接下来的m行，每行有三个整数u, v, l，表示u到v有一条长度为l的边。
', '
	共n-1行，第i行表示1号点到i+1号点的最短路。
', '[{"input": "\n3 3\n1 2 -1\n2 3 -1\n3 1 2\t\n\n", "output": "\n-1\n-2\n\n\t"}]', 'e94b98cc002d5dd9dd58b7ddf58c7363', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('最短路');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='最短路' limit 1),(select id from problem_tag where name='最短路' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('4-1打印下述图形', '　　使用循环结构打印下述图形，打印行数n由用户输入。打印空格时使用"%s"格式，向printf函数传递只包含一个或多个空格的字符串" ",下同。
', '', '', '[{"input": "一个满足题目要求的输入范例。\n例：\n\n5", "output": "与上面的样例输入对应的输出。\n例：\n"}]', '585d782b0013a27a56223fcb854c78b9', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 20);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('5-2求指数', '　　已知n和m，打印n^1，n^2，...，n^m。要求用静态变量实现。n^m表示n的m次方。已知n和m，打印n^1，n^2，...，n^m。要求用静态变量实现。n^m表示n的m次方。（每行显示5个数，每个数宽为12，右对齐）', '', '', '[{"input": "一个满足题目要求的输入范例。\n例：\n3 8", "output": "与上面的样例输入对应的输出。\n例：\n"}]', 'cea68a979cb814f5655e679d7eb5fce7', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 7);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('前缀表达式', '　　编写一个程序，以字符串方式输入一个前缀表达式，然后计算它的值。输入格式为：“运算符  对象1  对象2”，其中，运算符为“+”（加法）、“-”（减法）、“*”（乘法）或“/”（除法），运算对象为不超过10的整数，它们之间用一个空格隔开。要求：对于加、减、乘、除这四种运算，分别设计相应的函数来实现。
　　输入格式：输入只有一行，即一个前缀表达式字符串。
　　输出格式：输出相应的计算结果（如果是除法，直接采用c语言的“/”运算符，结果为整数）。
　　输入输出样例', '', '', '[{"input": "+ 5 2", "output": "7"}]', 'bb98c30824c95ce899ec2130328217fd', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('字符操作');INSERT INTO problem_tag(name) VALUES('数学知识');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='前缀表达式' limit 1),(select id from problem_tag where name='字符操作' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='前缀表达式' limit 1),(select id from problem_tag where name='数学知识' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('A Dicey Problem', '　　图1中3*3的网格是一个骰子地图。 一个标准的六面骰子需要在地图上移动（图2是一个标准六面骰子的展开图）。 每张地图有一个规定的初始位置和一个初始的骰子放置方式。在图1中，初始位置是第一行第二列——写着“2”的位置。假设你从地图的底边上观察，骰子的初始放置方式是底面（贴在地图上的那一面）是”2”，顶面（与底面相对的那一面）是“5”，”1”面向你。


　　你可以通过沿着骰子的一条边转动来将它移动到地图上水平或是竖直方向上相邻的格子上。假设当前骰子顶面的数字为x，那么你只能将它移动到写着x的格子上，或者画着星星图案的格子上。我们的最终目标是找到一条路径，使得骰子能从起点出发，最后又回到起点。
　　举个例子，在图1所示的地图中，一开始你有两种可行的移动方式——向下或者向左。由于此时骰子顶面所示的数字为”5”，当前格子下方的格子上写的数字也是”5”，因此向下移动骰子是可行的；因为当前位置左边的格子画着星星图案，因此向左移动是可行的。如果第一步选择向下移动，那么骰子朝上一面的图案会变成”6”，此时你可以向右或者向下移动骰子。如果第一步选择向左移动，那么骰子顶面的数字会变成3，这种情况下，任何移动方式都是不可行的。
　　我们用 (行号, 列号) 的方式来标记格子。行号从1开始，从上向下递增；列号从1开始，从左向右递增。这样，在上述例子中一个可行的解可以表示为：(1,2), (2,2), (2,3), (3,3), (3,2), (3,1), (2,1), (1,1), (1,2)。图3中展示了一个更加困难的例子。



　　在本题中，你需要编写程序对输入中给定的地图进行求解。每张地图可能存在一个唯一的解或者无解。也就是说，对于某一张地图，如果有解，你可以认为它只有一个解。对于每张地图，你需要输出一解或者一个信息表示无解。', '　　第一行包含6个用空格分隔的整数R, C, x0, y0, T, F，分别表示地图的行数、列数、初始位置行号、初始位置列号、初始状态下顶面的数字、初始状态下面向你的数字。
　　接下来的R行，每行包含C个空格分隔的整数，定义了这个地图。如果某个数是0，则表示对应的格子为空（不可以被走到）；如果某个数是-1，则表示对应单元格是画着星星图案的单元格；其余情况下，这个数表示对应格子上写的数字。', '　　若该地图无解，则输出一行“No Solution Possible” (不包含引号)。否则，你应该输出一个逗号分隔的位置序列，表示骰子依次经过的位置。注意你输出的第一个位置和最后一个位置应该是相同的（起始位置已在输入中规定），位置的格式如上文所示。除了最后一行外，每行应该包含九个位置。另外你的输出中不应包含空格。', '[{"input": "3 3 1 1 2 4\n2 2 3\n4 5 6\n-1 -1 -1", "output": "No Solution Possible"}]', '98e52841b0447cfa1bf4ab73d547ab22', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('BFS');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='A Dicey Problem' limit 1),(select id from problem_tag where name='BFS' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Bus Tour', '　　想象你是一个在Warsaw的游客，而且预订了一次乘车旅行，去城镇外看一些令人惊异的景点。这辆公共汽车首先围绕城镇行驶一段时间（一段很长的时间，由于Warsaw是一个大城市），把在各自旅馆的人们带上。接着它就去了那个令人惊异的景点，几个小时后又回到城市中，再一次行驶到每一个旅馆，这一次把乘客放下。
　　由于某种原因，每当你这样做的时候，你的旅馆总是第一个要上车的，而且是最后一个才下车的，意味着你不得不忍受两段经过所有当地旅馆的不那么愉快的旅行。这很明显不是你想要做的事（除非由于某种原因你真的要进入那些旅馆），所以让我们来做个改变。我们将开发一些软件使得那些观光公司能够把它们的乘车旅行路线安排得更公平——尽管这有时候可能会导致每一个人的总距离更长，但公平就是公平，不是吗？
　　对于这个问题，有一个起始位置（观光公司的总部），h个需要接送游客的旅馆和一个目的地位置（令人惊异的景点）。我们需要找到一条路径，从总部出发，经过所有的旅馆，到景点去，再回来再一次经过所有的旅馆（可能按照不同的顺序），最后返回总部。为了保证没有一个游客（特别是你）被迫忍受两个完整的旅馆旅行，我们要求在去景点的路上接游客的前个旅馆，在回来的路上也得是前个让游客下车的。受制于这些限制条件，我们想让整个公车旅行尽可能短。注意这些限制条件可能会迫使公共汽车经过某个旅馆但是不停下来（这不算做让游客下车），后来再来这里让游客下车，样例就说明了这种情况。', '　　第一行包含两个整数n和m满足3≤n≤20,2≤m，n是位置的总数（旅馆，总部和景点），m是汽车能在两个位置之间行驶的路径条数。
　　n个不同的位置被标号为0到n-1,0是总部，1到n-2是旅馆，而n-1是景点。假定任意一对位置之间最多只有一条直接路径，而且从任意一个位置都能到达任意另一个位置（并不一定直接到达）。
　　接下来m行，每行包含三个整数u，v和t，满足0≤u，v≤n-1，u≠v，1≤t≤3600，表示公共汽车可以在t秒的时间内直接在u和v之间到达（两个方向都可以）。', '　　一个整数，表示可能的最短路线的总耗时。', '[{"input": "5 4\n0 1 10\n1 2 20\n2 3 30\n3 4 40", "output": "300"}]', '16440412f9bf6d05f835bb11703e20a6', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 6);INSERT INTO problem_tag(name) VALUES('状压DP');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Bus Tour' limit 1),(select id from problem_tag where name='状压DP' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('8-2求完数', '　　如果一个自然数的所有小于自身的因子之和等于该数，则称为完数。设计算法，打印1-9999之间的所有完数。', '', '', '[]', '8a62b34bc584ccf64cecd877456a15f4', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('6-1 递归求二项', '', '', '', '[{"input": "一个满足题目要求的输入范例。\n3 10", "output": "与上面的样例输入对应的输出。\n"}]', 'fdceade7cfb70af30c6fc38022fd7618', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 5);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Collecting Luggage', '　　航班结束后，提取行李的过程并不琐碎。手提箱和行李箱出现在一条传送带上，数百名乘客争夺有利的位置从中找到并取回自己的所有物。近日，成田机场管理局已决定使这一过程更加高效。在重新设计行李认领区前，他们需要一个模拟程序，使得乘客认领行李时的耗时更平均。这个模拟假定乘客们走一条由直线段组成的路径并使用最少的时间走到他们的行李处。
　　对于这个问题，传送带被描述为一个简单多边形。在传送带的某些点上出现一件行李，然后以恒定的速度沿着传送带移动。乘客一开始在一个传送带组成的多边形外的点。在行李出现的同时，乘客以恒定的速度（大于行李移动的速度）移动去提取行李。乘客的路径可以接触但不能穿过传送带，且能让乘客在最短的时间内和行李位于同一个点。
　　在接下来这幅图中，传送带被描述成多边形ABCDEF。行李开始在左上角（A点）并按时针方向沿多边形边缘移动，如小箭头所示。乘客一开始在P点，并开始按最短的时间能和行李到达同一点（图中M点）的路径移动。乘客的移动路径如红色箭头所示。该图对应第一个输入样例。

', '　　输入包含一个或多个测试点来描述领取行李的场景。一个场景描述开头一行为一个单独的整数N(3<=N<=100)，多边形的顶点数。接下来N行每行两个整数xi,yi,(|xi|,|yi|<=10000)，按逆时针顺序给出多边形顶点的坐标。多边形是简单多边形，也就是说它不自交，不重合。多边形的描述后接下来一行两个整数px,py(|px|,|py|<=10000)，乘客起始位置所在点的坐标。接下来两个正整数VL,VP(0<VL<VP<=10000)，分别是行李和乘客的速度。所有坐标的单位是米，速度的单位是米/分钟。
　　你可以假设乘客位于多边形外。行李将会从多变形的第一个顶点开始按逆时针顺序沿传送带移动。
　　输入以一行一个单独的0结束。', '　　对于每组数据，输出一行，包括测试数据编号（从1开始编号）和乘客取得行李的最少时间。使用格式如样例输出所示（用冒号隔开分钟和秒），四舍五入到最近的整数。秒数占两位（不足用前导0补齐）。', '[{"input": "6\n0 40\n0 0\n20 0\n20 20\n40 20\n40 40\n120 40\n70 100\n4\n0 0\n10 0\n10 10\n0 10\n100 100\n10 11\n0", "output": "Case 1: Time = 1:02\nCase 2: Time = 12:36"}]', 'dd3fbb025fc8e960869d0d067df24317', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 6);INSERT INTO problem_tag(name) VALUES('最短路，计算几何');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Collecting Luggage' limit 1),(select id from problem_tag where name='最短路，计算几何' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Torry的困惑', '　　Torry从小喜爱数学。一天，老师告诉他，像2、3、5、7……这样的数叫做质数。Torry突然想到一个问题，前10、100、1000、10000……个质数的乘积是多少呢？他把这个问题告诉老师。老师愣住了，一时回答不出来。于是Torry求助于会编程的你，请你算出前n个质数的乘积。不过，考虑到你才接触编程不久，Torry只要你算出这个数模上50000的值。', '　　仅包含一个正整数n，其中n<=100000。', '　　输出一行，即前n个质数的乘积模50000的值。', '[]', '66483bbf1c460fbbd7202363631025c4', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 6);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Pollution Solution', '　　作为水污染管理部门的一名雇员，你需要监控那些被有意无意倒入河流、湖泊和海洋的污染物。你的其中一项工作就是估计污染物对不同的水生态系统（珊瑚礁、产卵地等等）造成的影响。


　　你计算所使用的模型已经在图1中被说明。海岸线（图1中的水平直线）为x轴，污染源位于原点(0, 0)。污染的蔓延呈半圆形，多边形代表了被波及的生态系统。你需要计算出生态系统被污染的面积，也就是图中深蓝色部分。', '　　输入文件包含仅包含一组测试数据。
　　每组测试数据第一行为两个整数n (3 <= n <= 100), r (1 <= r <= 1000)，n表示了多边形的顶点个数，r表示了污染区域的半径；
　　接下来n行，每行包含两个整数xi (-1500 <= xi <= 1500), yi (0 <= yi <=1500)，表示每个顶点的坐标，以逆时针顺序给出；
　　数据保证多边形不自交或触及自身，没有顶点会位于圆弧上。', '　　输出多边形被圆心位于原点、半径为r的半圆覆盖的面积。
　　答案的绝对误差不得超过10^-3。', '[{"input": "6 10\n-8 2\n8 2\n8 14\n0 14\n0 6\n-8 14", "output": "101.576437872"}]', '817353fe5fb7b638c45d5709c0018320', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 3);INSERT INTO problem_tag(name) VALUES('计算几何');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Pollution Solution' limit 1),(select id from problem_tag where name='计算几何' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('逆序对', '
Alice是一个让人非常愉跃的人!他总是去学习一些他不懂的问题，然后再想出许多稀奇古怪的题目。这几天，Alice又沉浸在逆序对的快乐当中，他已近学会了如何求逆序对对数，动态维护逆序对对数等等题目，他认为把这些题让你做简直是太没追求了，于是，经过一天的思考和完善，Alice终于拿出了一道他认为差不多的题目：
有一颗2n-1个节点的二叉树，它有恰好n个叶子节点，每个节点上写了一个整数。如果将这棵树的所有叶子节点上的数从左到右写下来，便得到一个序列a[1]…a[n]。现在想让这个序列中的逆序对数量最少，但唯一的操作就是选树上一个非叶子节点，将它的左右两颗子树交换。他可以做任意多次这个操作。求在最优方案下，该序列的逆序对数最少有多少。
Alice自己已近想出了题目的正解，他打算拿来和你分享，他要求你在最短的时间内完成。
', '
第一行一个整数n。
下面每行，一个数x。
如果x=0，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息，如果x≠0，表示这个节点是叶子节点，权值为x。
', '
	输出一个整数，表示最少有多少逆序对。
', '[{"input": "\n3\n0\n0\n3\n1\n2\n", "output": "\n1\n\t"}]', 'feb0db63af2d1d4407c67da78e2251e4', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('平衡二叉树');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='逆序对' limit 1),(select id from problem_tag where name='平衡二叉树' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('字串逆序', '　　给定一个字符串，将这个串的所有字母逆序后输出。', '　　输入包含一个字符串，长度不超过100，字符串中不含空格。', '　　输出包含一个字符串，为上面字符串的逆序。', '[{"input": "tsinsen", "output": "nesnist"}]', '5197e7a316cd50186db39f3a176c3d03', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 13);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('K好数', '
如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。
', '
输入包含两个正整数，K和L。
', '
	输出一个整数，表示答案对1000000007取模后的值。
', '[{"input": "\n4 2\n", "output": "\n7\n\t"}]', 'b1cbf789f1f44032601fa69ca1a634cf', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='K好数' limit 1),(select id from problem_tag where name='动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('未名湖边的烦恼', '　　每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。
　　每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）', '　　两个整数，表示m和n', '　　一个整数，表示队伍的排法的方案数。', '[{"input": "3 2", "output": "5"}]', '9c8b6dc97e5273d20693ed450f076491', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 3);INSERT INTO problem_tag(name) VALUES('递归');INSERT INTO problem_tag(name) VALUES('递推');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='未名湖边的烦恼' limit 1),(select id from problem_tag where name='递归' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='未名湖边的烦恼' limit 1),(select id from problem_tag where name='递推' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Lift and Throw', '　　给定一条标有整点(1, 2, 3, ...)的射线. 定义两个点之间的距离为其下标之差的绝对值.
　　Laharl, Etna, Flonne一开始在这条射线上不同的三个点, 他们希望其中某个人能够到达下标最大的点.
　　每个角色只能进行下面的3种操作, 且每种操作不能每人不能进行超过一次.
　　1.移动一定的距离
　　2.把另一个角色高举过头
　　3.将举在头上的角色扔出一段距离
　　每个角色有一个movement range参数, 他们只能移动到没有人的位置, 并且起点和终点的距离不超过movement range.
　　如果角色A和另一个角色B距离为1, 并且角色B没有被别的角色举起, 那么A就能举起B. 同时, B会移动到A的位置,B原来所占的位置变为没有人的位置. 被举起的角色不能进行任何操作, 举起别人的角色不能移动.同时, 每个角色还有一个throwing range参数, 即他能把举起的角色扔出的最远的距离. 注意, 一个角色只能被扔到没有别的角色占据的位置. 我们认为一个角色举起另一个同样举起一个角色的角色是允许的. 这种情况下会出现3个人在同一个位置的情况. 根据前面的描述, 这种情况下上面的两个角色不能进行任何操作, 而最下面的角色可以同时扔出上面的两个角色. 你的任务是计算这些角色能够到达的位置的最大下标, 即最大的数字x, 使得存在一个角色能够到达x.', '　　输入共三行, 分别为Laharl, Etna, Floone的信息.
　　每一行有且仅有3个整数, 描述对应角色的初始位置, movement range, throwing range.
　　数据保证3个角色的初始位置两两不相同且所有的数字都在1到10之间.</div>', '　　仅有1个整数, 即Laharl, Etna, Flonne之一能到达的最大距离.', '[{"input": "9 3 3\n4 3 1\n2 3 3", "output": "15"}]', '92aaa04e926f73612adb52a3ebe7b6e5', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 16);INSERT INTO problem_tag(name) VALUES('搜索');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Lift and Throw' limit 1),(select id from problem_tag where name='搜索' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('The Ministers  Major', '　　在一个名为 Stanistan 的遥远国度，大臣们在做决策时遇到了很严重的问题。几周前的一次新的议案投票进程引发了这个问题，这个进程的每次会议中，有若干议案被投票。每个大臣会对某些议案投票表示赞成或反对。由于票数统计等一系列技术方案在设计上局限性，每个大臣只能对最多四个不相同的议案投票（但这几乎不成问题，因为大多数大臣只对少数议题感兴趣）。得到了这些投票之后，议案将被决定是否通过，使得每个大臣有大于一半的建议被满足。

　　许多聪明的读者也许已经发现，这个进程导致了各种问题。比方说，可能有多个方案符合要求，或者说没有一种方案符合要求，就算只有一种方案，又该怎样得到这个方案。

　　你的任务就是写一个程序来帮助大臣们解决这些问题。给出每个大臣的投票，你的程序需要指出是否每个大臣都能被满足，如果是，请指出哪些议案只能被通过或否决。', '　　输入第一行两个数 n,m，分别表示议案个数和大臣人数。

　　接下来 m 行给出大臣们的投票，每行第一个数 k (1 ≤ k ≤ 4)，表示这个大臣投的票数。接下来是 k 个投票，每个投票都是  <bill> <vote> 的格式，其中 <bill> 是一个 1 到 n 的整数表示被投票的议案编号，<vote> 是 y 或 n，表示大臣的意见是通过还是否决。数据保证没有大臣会对同一个议案投票多次。', '　　输出一行。如果不可能满足所有大臣，那么输出 impossible。否则输出一个长度为 n 的字符串，如果编号为 i 的议案一定要通过，那么字符串的第 i 位为 y，如果一定不能通过则为 n，否则为 ?。', '[{"input": "4 2\n4 1 y 2 y 3 y 4 y\n3 1 n 2 n 3 n", "output": "impossible"}]', '331809f2a75f906aeef10229b9d5eb41', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);INSERT INTO problem_tag(name) VALUES('2-SAT');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='The Ministers  Major' limit 1),(select id from problem_tag where name='2-SAT' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Air Conditioning Mac', '　　你是一个Air Conditioning Machinery公司（ACM）的技术人员（就是装空调的）。不幸的是，当你到一个客户那里去装空调管道的时候，你发现你的管道不够了。你只剩6条管道，他们都是同一型号的弯管。
　　你必须在指定的空间内装一个管道。空间是一个长方体，所有的边的都是单位长度的整倍数，可以想象为一个空间堆满了单位正方体。每个弯管占用恰好4个单位的正方体，如下图1所示。两个弯管不能重合在同一个单位正方体上。每个弯管只有2个口，它们在图形1中以灰色显示。你可以把2个弯管接成一根长的管子，但是它们不得超过给定的空间。图2表示了其中一种对接方式。你的任务是接通入口和出口。入口和出口在给定空间的外表面上，和单位正方体对齐，如图3所示。为了减少开支，你必须用最少的弯管解决这个问题。
', '　　输入有多个case，每个case 1行包含11个用空格隔开的值。
　　前3个是整数(xmax,ymax,zmax)表示给定长方体的长宽高。长方体内的每个单位正方体用坐标(x,y,z)表示，其中1≤x≤xmax, 1≤y≤ymax, 1≤z≤zmax。xmax,ymax,zmax均为正且不大于20。
　　接下来3个整数，表示入口所在单位立方体的坐标。
　　接下来是2个字符构成的字符串，表示进入的朝向。可能为以下的一种：+x,-x,+y,-y,+z,-z。举例来说，如果为+y，代表进入的方向为y轴正方向，所以入口面向y轴负方向。
　　接下来3个整数，表示出口所在单位立方体的坐标。
　　最后是2个字符构成的字符串，表示流出的朝向。可能为以下的一种：+x,-x,+y,-y,+z,-z。举例来说，如果为+y，代表出去的方向为y轴正方向，所以出口面向y轴正方向。(注意与上面的不同之处。)
　　输入文件的最后一行有1个0，表示输入文件的结束。', '　　对于每个case，输出case编号（从1开始），并输出接通管道，并且不超过指定空间，最少需要的弯管数。如果不可能用6个弯管完成，则输出Impossible。详见样例。', '[{"input": "5 4 3 3 1 1 +z 5 4 3 +x\n5 4 3 3 1 1 +z 1 2 3 -x\n0", "output": "Case 1: 2\nCase 2: Impossible"}]', 'e23a426e8aee2b4ce17178bbc7c385ee', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);INSERT INTO problem_tag(name) VALUES('搜索');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Air Conditioning Mac' limit 1),(select id from problem_tag where name='搜索' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('A+B Problem', '　　输入A,B。
　　输出A+B。', '　　输入包含两个整数A,B，用一个空格分隔。', '　　输出一个整数，表示A+B的值。', '[{"input": "5 8", "output": "13"}]', 'fcec3d83877f05ee8de4f0d49be475fd', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 17);INSERT INTO problem_tag(name) VALUES('试用');INSERT INTO problem_tag(name) VALUES('C++');INSERT INTO problem_tag(name) VALUES('入门');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='A+B Problem' limit 1),(select id from problem_tag where name='试用' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='A+B Problem' limit 1),(select id from problem_tag where name='C++' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='A+B Problem' limit 1),(select id from problem_tag where name='入门' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('A Major Problem', '　　在西方音乐中，用大写字母A到G来表示在乐谱中被使用的12个音符，它们后面可能连有升调符号“#”和降调符号“b”，而且如下面展示的那样循环排列。斜杠用来描述相同音符。
　　C/B# C#/Db D D#/Eb E/Fb F/E# F#/Gb G G#/Ab A A#/Bb B/Cb C/B# …
　　上表中任意两个相邻音符构成一个半音。恰被一个音符隔开的两个音符构成一个全音。一个大调音阶由八个音符组成。它由上述之一的音符开始并且紧跟着连续的“全音-全音-半音-全音-全音-全音-半音”。分别由C和Db开始的两个大调音阶，将由下面的音符组成：
　　C D E F G A B C
　　Db Eb F Gb Ab Bb C Db
　　下面的规则同样适用于大调音阶：
　　1.       A到G的每个字母将在音阶中出现恰好一次，同时第一个字母将例外地在音阶最后重复出现一次。
　　2.       音阶当中不允许同时出现升调或降调记号。

　　大调音阶的首个音符被认为是这个音阶的曲调。比方说，上面的两个音阶分别是C和Db大调音阶。更换两个音阶的音符就是交换对应位置的音符那么简单。举个例子，C大调音阶中的F会和Db大调音阶中的Gb交换因为它们在各自音阶中的位置相同。
　　你需要写一个程序，在不同音阶中交换音符。', '　　输入包含多组数据，每行一组。每行开头是一个源曲调，紧跟着一个目标曲调，接下来是一串需要从源曲调大调音阶交换至目标曲调大调音阶的音符。每行由单个星号结束。每行中的音符和星号都由单个空格隔开。
　　输入的最后一行只包含一个星号，并不作为测试数据。', '　　每组测试数据可能对应一行或多行输出。如果源调和目标调都是有效的，那么输出的第一行应该是“Transposing from X to Y:”，X代表源调，Y代表目标调。假如源调或者目标调中有一个是无效的，那么输出“Key of X/Y is not a valid major key”，X/Y表示无效的曲调，改行剩下的输入将被忽略。假如两者皆无效，只需输出源调。
　　对于包含了有效的源调和目标调的数据，在第一行的输出后，每个被交换的音符都对应一行输出。假如输入的音符在源调的大调音阶中是个有效音符，那么输出“M transposes to N”，M表示源调中的音符，N是目标调中对应位置的音符。假如输入的音符在源大调音阶中无效，那么输出“M is not a valid note in the X major scale”，M代表输入音符，X代表源音调。不管是有效还是无效音符，都要保持一致的缩进格式。
　　各组数据的输出之间应该用一个空行隔开。你的输出格式应该要和下面的标准输出相同。

　　输入和输出的标准格式请参考未格式化的试题。', '[]', '394b6e518f4f116a95dc04ea6f25da53', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 20);INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='A Major Problem' limit 1),(select id from problem_tag where name='模拟' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('寻找数组中最大值', '　　对于给定整数数组a[],寻找其中最大值，并返回下标。', '　　整数数组a[],数组元素个数小于1等于100。输出数据分作两行：第一行只有一个数，表示数组元素个数；第二行为数组的各个元素。', '　　输出最大值，及其下标', '[]', 'd13957775a33bfc67b8c17e556071082', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 10);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('简单加法', '　　首先给出简单加法算式的定义：
　　如果有一个算式(i)+(i+1)+(i+2),(i>=0)，在计算的过程中，没有任何一个数位出现了进位，则称其为简单的加法算式。
　　例如：i=3时，3+4+5=12，有一个进位，因此3+4+5不是一个简单的加法算式；又如i=112时，112+113+114=339，没有在任意数位上产生进位，故112+113+114是一个简单的加法算式。

　　问题：给定一个正整数n，问当i大于等于0且小于n时,有多少个算式(i)+(i+1)+(i+2)是简单加法算式。其中n<10000。', '　　一个整数，表示n', '　　一个整数,表示简单加法算式的个数', '[]', '41b9245ddd4b4caf811f29ab525c78a7', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 15);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('5-1最小公倍数', '　　编写一函数lcm，求两个正整数的最小公倍数。', '', '', '[{"input": "一个满足题目要求的输入范例。\n例：\n\n3 5", "output": "与上面的样例输入对应的输出。\n例：\n"}]', '103e7b0165d8bdbde82e097bfe75158d', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 19);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('最大最小公倍数', '
已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。
', '
输入一个正整数N。
', '输出一个整数，表示你找到的最小公倍数。', '[{"input": "9", "output": "504"}]', '77a66e83baac609a60f731b6490f6c22', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 19);INSERT INTO problem_tag(name) VALUES('贪心');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='最大最小公倍数' limit 1),(select id from problem_tag where name='贪心' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Consanguine Calculat', '　　每个人的血型都有两个标记，这两个标记被叫做ABO血型系统的等位基因，每个标记都代表了ABO三个字母之一，因此我们有6种可能的基因组合，而每一种组合都表示了一个特定的ABO血型。
　　组合     ABO血型
　　AA       A
　　AB       AB
　　AO       A
　　BB       B
　　BO       B
　　OO       O
　　与之相对应的，每个人同样有两个Rh血型系统的等位基因，而这两个等位基因的标记是+或-。某个人如果是Rh+血型则至少含有一个+基因，而如果是Rh-血型则一定含有两个-基因。
　　所以一个人的血型是ABO血型系统和Rh血型系统的组合，血型的书写方式是先写ABO血型后写Rh血型。例如A+、AB-、O-。
　　血型是可以继承的：父母分别贡献一个ABO血型基因和一个Rh血型基因（随机从两个中选择）给他们的孩子。因此父母的2个ABO血型基因和Rh血型基因决定了孩子的血型。比如父母都是A-，则他们的孩子会是A-或O-；而父母是A+和B+时，孩子可以是任意血型。
　　在本题中，你会得到父母和孩子三者中两者的基因，你需要确定剩下的那个人所有可能的血型组合。
　　注：我们用大写字母和+-号表示血型，而不是数字。', '　　输入包含若干组数据，每组数据占一行，先是父亲的基因，接着是母亲的基因，最后是孩子的基因，其中一个人的基因用问号代替。输入中空格会在任何地方出现，除了在一个血型中间。
　　最后一行包含三个用空格隔开的字符E、N、D。', '　　对于每组数据，输出其编号，并按顺序输出父母和孩子的血型。如果没有可行的方案，输出IMPOSSIBLE；如果有多种方案，输出所有可行的方案，方案之间用逗号分隔，并用大括号围住（只有一种方案时不加大括号和逗号）。方案顺序随意。
　　样例包含多组数据和多种方案，你的输出格式需要与之类似，注意空格出现的位置和字母大小写。', '[{"input": "O+ O- ?\nO+ ? O-\nAB- AB+ ?\nAB+ ? O+\nO- O- ?\nE N D", "output": "Case 1: O+ O- {O+, O-}\nCase 2: O+ {A+, A-, B+, B-, O+, O-} O-\nCase 3: AB- AB+ {A+, A-, B+, B-, AB+, AB-}\nCase 4: AB+ IMPOSSIBLE O+\nCase 5: O- O- O-"}]', '4494ea8281f4097b55c0632343260b64', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Consanguine Calculat' limit 1),(select id from problem_tag where name='枚举' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Partitions', '　　一个矩形的划分是指把一个矩形分成若干个较小的、不重叠的子矩形。图一展示了几个划分的例子。


　　图二展示了被划分成子矩形的三个相同大小的矩形。B是A通过划分A的两个子矩形得来的。通常的，如果B是A通过划分它的一个或多个子矩形得来，那么我们说B比A更精细，或者说A比B更粗糙。这一关系是偏序的：例如C不比A,B中的任意一个精细或粗糙。

　　给定同一矩形的两种划分D和E，存在无穷多的比D和E都要精细。在图三中F和G都比D和E要精细。在比D和E精细的划分中，存在唯一的一种最粗糙的划分。这种划分被称为D和E的下确界。在图三中，F是D和E的下确界。


　　在图四中H和J都比D和E粗糙。J是比D和E都粗糙的所有划分中最精细的，所以称J为D和E的上确界。

　　写一个程序，给出两种对于相同矩形的划分，求出它们的下确界和上确界。', '　　输入文件包括一个或多个测试数据。每个数据第一行给出矩形的宽度h和高度w(0<w,h<21)。接下来h+1如样例所示给出两种划分。每行包括4*w+3个字符。其中前2*w+1个字符属于第一种划分；最后2*w+1个字符属于第二种划分。一个空格分开两种划分，水平线条用下划线“_”表示，垂直线条用“|”。

　　输入以两个0结束。', '　　对于输入文件每个数据，输出包括单独一行数据编号(格式如样例所示)，其次是两种划分的下确界和上确界，使用和输入数据相同个格式。
　　每组数据后输出一个空行。', '[{"input": "", "output": ""}]', '74877db51303ff7d79ed3507266de68a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 19);INSERT INTO problem_tag(name) VALUES('模拟，floodfill');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Partitions' limit 1),(select id from problem_tag where name='模拟，floodfill' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Eurodiffusion', '　　2002年1月1日，12个欧洲国家放弃了它们原来的货币，开始使用欧元。从此，在整个欧元区，再也没有了法郎、马克、里拉、基尔德、克朗……，只有欧元。这些国家使用的纸币相同，但是硬币也相同？不完全是这样。每个国家都有一定的自由来制造自己的欧元硬币：
　　“每个欧元硬币的一面都有同样的欧洲地形，在另一面，成员国可以用自己的图形装饰硬币。无论哪种图形的硬币，都可以在12个成员国的任何地方使用。比如，一个法国公民可以使用含有西班牙国王印记的欧元硬币，在柏林买到一个热狗。”（来源于http://europa.eu.int/euro/html/entry.html）
　　在2002年1月1日，巴黎唯一的欧元硬币是法国硬币。不久，第一种非法国硬币出现在巴黎。最终，人们可能会认为所有类型的硬币平均分布在12个成员国（其实并不是这样，因为所有国家一直都在发行自己的硬币，所以即使在稳定的情况下，在柏林，德国硬币应该都是最多的）。所以，多久以后芬兰或爱尔兰的硬币才会第一次在意大利南部流通？每种硬币要多久以后才能出现在所有的地方？
　　因此，你需要写一个程序来模拟欧元硬币在整个欧洲的传播过程。这里使用一种高度简化的模型，考虑单一的欧元面额。给出一个矩形网格，欧洲城市都在格点上，每个城市最多可以有4个邻接的城市（东西南北各一个）。每个城市都属于且仅属于一个国家，而且一个国家所有城市在平面上刚好组成一个矩形。下图是一个含有3个国家、28个城市的地图。

　　在地图上，国家之间是连通的，但国家之间可能含有洞，这表示海洋或像瑞士、丹麦这样的非欧元区国家。一开始，每个城市都只有一百万个本国的硬币，然后每一天，每个城市都按照它在这一天开始时的余额，将一定量的硬币送给它的所有邻接城市。这”一定量的硬币“指的是对于这个城市目前所拥有的每种图形的硬币，每满1000个就要拿出来一个。
　　当某个城市中，每种图形的硬币都至少出现了一个，就称这个城市“已经完成”。当一个国家的所有城市都已经完成的时候，就称这个国家已经完成。你的程序需要得出每个国家的完成时间。', '　　输入包含多组数据。每组数据的第一行是一个数c，表示国家的个数，接下来c行，每行描述一个国家。对于国家的描述按照以下格式：name xl yl xh yh，其中name是一个最多25个字符的字符串，表示国家名称，(xl, yl)表示这个国家左下角（西南角）的城市坐标，(xh, yh)表示这个国家右上角（东北角）的城市坐标。
　　最后一组数据之后是一个0。', '　　对于每组数据，先输出一行表示数据编号，接下来对每个国家输出一行，包括这个国家的名称以及它的完成时间（单位：天）。国家之间按照完成时间递增排序，如果两个国家的完成时间相同，按照国家名称的字典序递增排序。
　　按照样例输出的格式输出（国家名称之前空3格，国家名称和完成时间之间空3格，样例输出在排版的时候可能出了一点问题）。', '[{"input": "3\nFrance 1 4 4 6\nSpain 3 1 6 3\nPortugal 1 1 2 2\n1\nLuxembourg 1 1 1 1\n2\nNetherlands 1 3 2 4\nBelgium 1 1 2 2\n0", "output": "Case Number 1\nSpain   382\nPortugal   416\nFrance   1325\nCase Number 2\nLuxembourg   0\nCase Number 3\nBelgium   2\nNetherlands   2"}]', 'a6296d5532aa1167449b57960dec0e7b', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 14);INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Eurodiffusion' limit 1),(select id from problem_tag where name='模拟' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('快速排序', '　　快速排序是最经常使用的一种排序方式，对于给定的n个数组成的一个数组，请使用快速排序对其进行排序。
　　现给定一序列，请用快速排序将其按升序排序并输出。', '　　第一行一个数N。
　　第2~N+1行每行一个数，表示给定序列。', '　　共N行，每行一个数，表示所求序列。', '[{"input": "5\n1\n4\n2\n3\n4", "output": "1\n2\n3\n4\n4"}]', 'a83ae726ef06a68ff49d9f1a72dcde27', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Anagrams问题', '　　Anagrams指的是具有如下特性的两个单词：在这两个单词当中，每一个英文字母（不区分大小写）所出现的次数都是相同的。例如，“Unclear”和“Nuclear”、“Rimon”和“MinOR”都是Anagrams。编写一个程序，输入两个单词，然后判断一下，这两个单词是否是Anagrams。每一个单词的长度不会超过80个字符，而且是大小写无关的。
　　输入格式：输入有两行，分别为两个单词。
　　输出格式：输出只有一个字母Y或N，分别表示Yes和No。
　　输入输出样例', '', '', '[{"input": "Unclear\nNuclear", "output": "Y"}]', '4eab0c2d16925ed8aa13f2ca65803d77', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);INSERT INTO problem_tag(name) VALUES('数组运算');INSERT INTO problem_tag(name) VALUES('字符操作');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Anagrams问题' limit 1),(select id from problem_tag where name='数组运算' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Anagrams问题' limit 1),(select id from problem_tag where name='字符操作' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('区间k大数查询', '
给定一个序列，每次询问序列中第l个数到第r个数中第K大的数是哪个。
', '
第一行包含一个数n，表示序列长度。
第二行包含n个正整数，表示给定的序列。
第三个包含一个正整数m，表示询问个数。
接下来m行，每行三个数l,r,K，表示询问序列从左往右第l个数到第r个数中，从大往小第K大的数是哪个。序列元素从1开始标号。
', '
	总共输出m行，每行一个数，表示询问的答案。
', '[{"input": "\n5\n1 2 3 4 5\n2\n1 5 2\n2 3 2\n", "output": "\n4\n2\n\t"}]', '2ecbc973d4a65a27f11f2a722df5d56f', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('排序');INSERT INTO problem_tag(name) VALUES('查找');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='区间k大数查询' limit 1),(select id from problem_tag where name='排序' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='区间k大数查询' limit 1),(select id from problem_tag where name='查找' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Tiling the Plane', '　　对于一个多边形，如果可以通过它本身复制多次来不重不漏地覆盖一个无限的二维平面，我们就称这个多边形能铺满平面。图1展示了一个L型的多边形，图2展示了它如何不重不漏地铺满平面。你需要写一个程序来判断给出的多边形是否能铺满平面。

　　每组测试数据由一个闭合的多边形组成，这个多边形所有的角均为直角，每条边的长度均为单位长度的整数倍。你可以随意地复制这个多边形，也可以在平面上随意移动它们，但不能旋转或翻转任意一个多边形。

　　以下是一些可能有用的信息：
　　只有两种本质不同的铺满平面的情况：使用正四边形铺满平面（棋盘覆盖），或使用正六边形铺满平面（蜂巢覆盖）。一个多边形当且仅当满足以下两个条件中至少一个时可以铺满平面：
　　1.         在多边形边界上顺次存在四个点A,B,C,D（不一定要是多边形的顶点），使得A到B的边界与D到C的边界重合，B到C的边界与A到D的边界重合。这表明这个多边形可以用棋盘覆盖的方式铺满平面。
　　2.         在多边形边界上顺次存在六个点A,B,C,D,E,F（不一定要是多边形的顶点），使得A到B的边界与E到D的边界重合，B到C的边界与F到E的边界重合，C到D的边界与A到F的边界重合。这表明这个多边形可以用蜂巢覆盖的方式铺满平面。', '　　输入包含对多个多边形的描述，每一行表示一个询问的多边形。
　　每一行以一个整数n开始，表示多边形的边数。接下来按逆时针顺序描述每一条边，每一个描述都是一个字母后跟一个数字，字母是“N”、“E”、“S”或“W”，表示线段的方向分别为北、东、南或西，数字表示该线段长度是多少个单位。保证多边形不与自身连接或相交。
　　输入以单独一行“0”结束。', '　　对于每个多边形，输出一行。
　　首先输出多边形的编号，接下来如果该多边形能铺满平面，则输出“Possible”，如果该多边形不能铺满平面，则输出“Impossible”。具体见样例输出的格式。', '[{"input": "6 N 3 W 1 S 4 E 4 N 1 W 3\n8 E 5 N 1 W 3 N 3 E 2 N 1 W 4 S 5\n0", "output": "Polygon 1: Possible\nPolygon 2: Impossible"}]', '622c38170bfbb25e9797d50263194a97', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 17);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('字符串匹配');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Tiling the Plane' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Tiling the Plane' limit 1),(select id from problem_tag where name='字符串匹配' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Beaver s Calculator', '　　从万能词典来的聪明的海狸已经使我们惊讶了一次。他开发了一种新的计算器，他将此命名为"Beaver s Calculator 1.0"。它非常特别，并且被计划使用在各种各样的科学问题中。
　　为了测试它，聪明的海狸邀请了n位科学家，编号从1到n。第i位科学家给这个计算器带来了 ki个计算题。第i个科学家带来的问题编号1到n，并且它们必须按照编号一个一个计算，因为对于每个问题的计算都必须依赖前一个问题的计算结果。
　　每个教授的每个问题都用一个数  ai, j  来描述，i（1≤i≤n）是科学家的编号，j（1≤j≤ ki ）是问题的编号， ai, j  表示解决这个问题所需资源单位的数量。
　　这个计算器非常不凡。它一个接一个的解决问题。在一个问题解决后，并且在下一个问题被计算前，计算器分配或解放资源。
　　计算器中最昂贵的操作是解放资源，解放远远慢于分配。所以对计算器而言，每一个接下来的问题所需的资源不少于前一个，是非常重要的。
　　给你关于这些科学家所给问题的相关信息。你需要给这些问题安排一个顺序，使得“坏对”尽可能少。
　　所谓“坏对”，就是相邻两个问题中，后一个问题需求的资源比前一个问题少。别忘了，对于同一个科学家给出的问题，计算它们的相对顺序必须是固定的。', '　　第一行包含一个整数n，表示科学家的人数。接下来n行每行有5个整数，ki, ai, 1, xi, yi, mi (0 ≤ ai, 1 < mi ≤ 109, 1 ≤ xi, yi ≤ 109) ，分别表示第i个科学家的问题个数，第1个问题所需资源单位数，以及3个用来计算 ai, j 的参量。ai, j = (ai, j - 1 * xi + yi)mod mi。', '　　第一行输出一个整数，表示最优顺序下最少的“坏对”个数。
　　如果问题的总个数不超过200000,接下来输出  行，表示解决问题的最优顺序。每一行两个用空格隔开的整数，表示这个问题所需的资源单位数和提供这个问题的科学家的编号。', '[{"input": "2\n2 1 1 1 10\n2 3 1 1 10", "output": "0\n1 1\n2 1\n3 2\n4 2"}]', 'eeae5e97cff5d85a6dd79ff710b7583a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 6);INSERT INTO problem_tag(name) VALUES('排序');INSERT INTO problem_tag(name) VALUES('贪心');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Beaver s Calculator' limit 1),(select id from problem_tag where name='排序' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Beaver s Calculator' limit 1),(select id from problem_tag where name='贪心' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('表达式计算', '　　输入一个只包含加减乖除和括号的合法表达式，求表达式的值。其中除表示整除。', '　　输入一行，包含一个表达式。', '　　输出这个表达式的值。', '[{"input": "1-2+3*(4-5)", "output": "-4"}]', '588bbdf89c16b2042f58de8141a4f2f5', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);INSERT INTO problem_tag(name) VALUES('表达式');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='表达式计算' limit 1),(select id from problem_tag where name='表达式' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('操作格子', '
有n个格子，从左到右放成一排，编号为1-n。
共有m次操作，有3种操作类型：
1.修改一个格子的权值，
2.求连续一段格子权值和，
3.求连续一段格子的最大值。
对于每个2、3操作输出你所求出的结果。
', '
第一行2个整数n，m。
接下来一行n个整数表示n个格子的初始权值。
接下来m行，每行3个整数p,x,y，p表示操作类型，p=1时表示修改格子x的权值为y，p=2时表示求区间[x,y]内格子权值和，p=3时表示求区间[x,y]内格子最大的权值。
', '
有若干行，行数等于p=2或3的操作总数。
每行1个整数，对应了每个p=2或3操作的结果。
', '[{"input": "\n4 3\n1 2 3 4\n2 1 3\n1 4 3\n3 1 4\n", "output": "\n6\n3\n\t"}]', '942e7547abbbdd557054b02bc84cd4bb', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 5);INSERT INTO problem_tag(name) VALUES('线段树');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='操作格子' limit 1),(select id from problem_tag where name='线段树' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Balloons in a Box', '　　你要写一个程序，使得能够模拟在长方体的盒子里放置球形的气球。
　　接下来是模拟的方案。假设你已知一个长方体的盒子和一个点集。每一个点代表一个可以放置气球的位置。在一个点上放置一个气球，就是以这个点为球心，然后让这个球膨胀，直到触及盒子的边缘或者一个之前已经被放置好的气球。你不能使用一个在盒子外面或者在一个之前已经放置好的气球里面的点。但是，你可以按你喜欢的任意顺序使用这些点，而且你不需要每个点都用。你的目标是按照某种顺序在盒子里放置气球，使得气球占据的总体积最大。
　　你要做的是计算盒子里没被气球占据的体积。', '　　第一行包含一个整数n表示集合里点的个数（1≤n≤6）。第二行包含三个整数表示盒子的一个角落的(x,y,z)坐标，第三行包含与之相对的那个角落的(x,y,z)坐标。接下来n行，每行包含三个整数，表示集合中每个点的(x,y,z)坐标。这个盒子的每维的长度都是非零的，而且它的边与坐标轴平行。', '　　只有一行，为那个盒子没被气球占据的最小体积（四舍五入到整数）。', '[{"input": "2\n0 0 0\n10 10 10\n3 3 3\n7 7 7", "output": "774"}]', '3edb0bb7634ca2ede46447f486e50318', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('几何');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Balloons in a Box' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Balloons in a Box' limit 1),(select id from problem_tag where name='几何' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('最大的算式', '　　题目很简单，给出N个数字，不改变它们的相对位置，在中间加入K个乘号和N-K-1个加号，（括号随便加）使最终结果尽量大。因为乘号和加号一共就是N-1个了，所以恰好每两个相邻数字之间都有一个符号。例如：
　　N=5，K=2，5个数字分别为1、2、3、4、5，可以加成：
　　1*2*(3+4+5)=24
　　1*(2+3)*(4+5)=45
　　(1*2+3)*(4+5)=45
　　……', '　　输入文件共有二行，第一行为两个有空格隔开的整数，表示N和K，其中（2<=N<=15, 0<=K<=N-1）。第二行为 N个用空格隔开的数字（每个数字在0到9之间）。', '　　输出文件仅一行包含一个整数，表示要求的最大的结果', '[{"input": "5 2\n1 2 3 4 5", "output": "120"}]', 'fbd015168ec4bd0f7c451510cac55e74', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tag(name) VALUES('资源分配类型（最大乘积）');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='最大的算式' limit 1),(select id from problem_tag where name='动态规划' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='最大的算式' limit 1),(select id from problem_tag where name='资源分配类型（最大乘积）' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Crossing the Desert', '　　在这个问题中，你需要计算出你为了徒步穿越沙漠而需要购买的食物量。
　　在你的出发地你可以在商店里购买食物而且你可以收集到无限的免费的水。沙漠中间可能存在一些绿洲。在每个绿洲你同样可以收集无限的水和储存食物，但是你没法再绿洲购买新的食物，同样的你在出发地也可以储存食物。你会得到起点、所有绿洲和终点的二维坐标，这些地方都可以视为平面直角坐标系上的点，在坐标系上每走过一单位相当于实际走一英里。
　　你每走一英里，你就需要消耗一单位食物和一单位水。我们假设这消耗是持续进行的，即你走了x英里就消耗了x单位食物和水。你只有当食物和水足够时才能前进，而当你在绿洲休息时则不会消耗食物和水。当然你也有你可以携带的食物和水的上限，而这上限就是你能携带的食物和水的单位和的最大值，任何时候你都不能携带超过上限的食物和水。
　　你需要确定到达终点所需要购买的最少食物量，你不需要在到达终点时还有食物和水盈余。由于商店只能整单位售卖食物且只有一百万单位的存货，你的答案必须是大于0小于等于一百万的整数。

　　请注意样例！', '　　第一行包含两个整数n和tot，表示有意义的位置的坐标个数和能携带的单位数量上限。接下来n行每行两个整数x和y，其中第一个坐标表示起点，最后一个坐标表示终点，中间其他的坐标都是绿洲。你不必经过所有绿洲，也不必按特定的顺序经过绿洲。', '　　有解时，输出你需要的最小食物量，无解时，输出Impossible。具体格式见样例。', '[{"input": "样例1：\n4 100\n10 -20\n-10 5\n30 15\n15 35\n样例2：\n2 100\n0 0\n100 100\n样例3：\n2 100\n0 0\n0 1", "output": "样例1：\n136 units of food\n样例2：\nImpossible\n样例3：\n1 unit of food"}]', '5285a37e45c5bca300e882e570b682cd', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);INSERT INTO problem_tag(name) VALUES('数论');INSERT INTO problem_tag(name) VALUES('图论');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Crossing the Desert' limit 1),(select id from problem_tag where name='数论' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Crossing the Desert' limit 1),(select id from problem_tag where name='图论' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Hello World!', '', '　　无', '　　Hello World!', '[]', '724430f12c1efa4916b1bdb1884efc2f', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 20);INSERT INTO problem_tag(name) VALUES('输出格式');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Hello World!' limit 1),(select id from problem_tag where name='输出格式' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Cowboys', '　　一个间不容发的时刻：n个牛仔站立于一个环中，并且每个牛仔都用左轮手枪指着他旁边的人！每个牛仔指着他顺时针或者逆时针方向上的相邻的人。正如很多西部片那样，在这一刻，绳命是入刺的不可惜……对峙的场景每秒都在变化。每秒钟牛仔们都会分析局势，当一对相邻的牛仔发现他们正在互指的时候，就会转过身。一秒内每对这样的牛仔都会转身。所有的转身都同时在一瞬间发生。我们用字母来表示牛仔所指的方向。“A”表示顺时针方向，“B”表示逆时针方向。如此，一个仅含“A”“B”的字符串便用来表示这个由牛仔构成的环。这是由第一个指着顺时针方向的牛仔做出的记录。例如，牛仔环“ABBBABBBA”在一秒后会变成“BABBBABBA”；而牛仔环“BABBA”会变成“ABABB”。 这幅图说明了“BABBA”怎么变成“ABABB” 一秒过去了，现在用字符串s来表示牛仔们的排列。你的任务是求出一秒前有多少种可能的排列。如果某个排列中一个牛仔指向顺时针，而在另一个排列中他指向逆时针，那么这两个排列就是不同的。', '　　输入数据包括一个字符串s，它只含有“A”和“B”。', '　　输出你求出来的一秒前的可能排列数。', '[]', '37ebe8e938eba529e1cc3b854b3455b1', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 10);INSERT INTO problem_tag(name) VALUES('递推');INSERT INTO problem_tag(name) VALUES('动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Cowboys' limit 1),(select id from problem_tag where name='递推' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Cowboys' limit 1),(select id from problem_tag where name='动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('According to Bartjen', '　　计算器和计算机的大量普及也有其弊端。即便是受过专业技术训练的学生们也很可能缺乏计算能力。由于电脑的大量使用，很多人无法心算出7*8这样的算式，甚至是用纸和笔也算不出13*17。不过谁在意呢？
　　Bartjens教授十分在意——因为他比较传统。他决定给学生布置一些计算作业，并且不能使用电子设备。为了批改方便，他决定使得几乎所有题答案都是2000，不过不全是，否则会被学生发现然后就不仔细计算了。
　　不幸的是，Bartjens教授的打印机实在是太旧了，不能和新的打印机兼容。打印出了题目后，教授发现所有的符号都丢失了！例如2100-100=，被打印成了2100100=。不过，数字和等号被正确的打印了。
　　更糟糕的是，教授的试题原稿不见了。因此，他需要恢复出这些题原来的样子。如果答案是2000，那么2100100=可能是：
　　2100-100=
　　2*100*10+0=
　　2*100*10-0=
　　2*10*0100=
　　2*-100*-10+0=
　　Bartjen教授记得几点：
　　1.他写的数字没有前导零。例如2*10*0100=就是不可行的。
　　2.他写0的时候不会写多个0。例如2*1000+000=就是不可行的。
　　3.他只用二元运算符，不用取负。所以2*-100*-10+0=也不合法。
　　4.他只用+、-、*，不用/和括号。
　　5.这些算式按照正常的优先级顺序计算。
　　你需要帮助barjen教授恢复这些题目。你需要在算式中插入至少一个运算符，使得答案是2000。有多少种可能的算式呢？', '　　输入包含一组数据。这组数据有n个数字（1<=n<=9），后面跟着一个=号。', '　　输出包含若干行，每一行是一个可行的解，具体格式见样例。按字典序从小到大输出这些字符串。如果无解，输出一行IMPOSSIBLE。', '[]', '88a8798da879fdeffbecb8e15533992b', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 10);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('表达式计算');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='According to Bartjen' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='According to Bartjen' limit 1),(select id from problem_tag where name='表达式计算' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('C++ CH08 01', '　　已知一个有理数类Zrf_Ratio，实现如下的操作符重载形式：
　　friend std::ostream& operator<<(std::ostream&, const zrf_Ratio&);//输出最简分数
　　friend std::istream& operator>>(std::istream&, zrf_Ratio&);
　　friend bool operator==(const zrf_Ratio&, const zrf_Ratio&);
　　friend bool operator<(const zrf_Ratio&, const zrf_Ratio&);', '', '', '[{"input": "1 7 26 25", "output": "zrf is:1/7; ssh is:26/25\n(zrf==ssh) is:0; (zrf<ssh) is:1"}]', 'b8ff6cb504a34bbd158188ded4e37bf8', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('最小乘积', '　　给两组数，各n个。
　　请调整每组数的排列顺序，使得两组数据相同下标元素对应相乘，然后相加的和最小。要求程序输出这个最小值。
　　例如两组数分别为:1 3　　-5和-2 4 1

　　那么对应乘积取和的最小值应为：
　　(-5) * 4 + 3 * (-2) + 1 * 1 = -25', '　　第一个行一个数T表示数据组数。后面每组数据，先读入一个n，接下来两行每行n个数，每个数的绝对值小于等于1000。
　　n<=8,T<=1000', '　　一个数表示答案。', '[]', '203f4ba64d8b97b4fd4ffaec75fffb61', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 12);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('数字三角形', '　　（图３.１－１）示出了一个数字三角形。 请编一个程序计算从顶至底的某处的一条路
　　径，使该路径所经过的数字的总和最大。
　　●每一步可沿左斜线向下或右斜线向下走；
　　●1＜三角形行数≤100；
　　●三角形中的数字为整数0，1，…99；


　　.
　　（图３.１－１）', '　　文件中首先读到的是三角形的行数。

　　接下来描述整个三角形', '　　最大总和（整数）', '[{"input": "5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5", "output": "30"}]', '4927d7ad81a7034a0e15b3dd7f55c199', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 10);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Don t fear, DravDe i', '　　这一天，有一列车子排起了一排长队，必经之路是一个被魔王笼罩的山洞。每辆车的司机害怕魔王程度不同，所以每个司机有一些要求。
　　车子有n台，排成一条长队，每辆车有4个属性:
　　V  ——这辆车的总价值，价值就是比如它其中的乘客和货物的价值
　　c  ——这辆车里面的人数量（司机表示自己也算一个乘客，司机和乘客不用区分开来）
　　l  ——在这辆车的前面需要总量正好为多少乘客的车（不多也不少），这车才敢开
　　r  ——在这辆车的后面需要总量正好为多少乘客的车（不多也不少），这车才敢开
　　“前面需要总量正好为多少乘客的车”指的是驶在这辆车前面所有的车的乘客总数。
　　“后面需要总量正好为多少乘客的车”指的是驶在这辆车后面所有的车的乘客总数。
　　你不能改变每辆车在车队的相对顺序，但你可以安排某些车退出车队，保证依然在车队的每辆车都敢开了，即满足上述条件，并且剩下车的v的总量最大。
　　-----------------------------
　　简单来说，给您按输入顺序排列的n辆车，您需要删去里面的一些车（剩下的车仍然按原相对顺序排列）。
　　使得对于每辆车，若它没被删去，设其为输入的第i辆车，
　　要满足
　　l[i]= sigma{c[j] | j<i 且第j辆车没被删去}
　　r[i]= sigma{c[j] | j>i 且第j辆车没被删去}
　　在满足这些条件前提下，要求sigma{V[i] | i没被删去} 最大，
　　请输出这个最大值，并且递增输出没有被删去的车的标号。', '　　输入的第一行为一个正整数n（1<=n<=10^5）——车的个数。
　　接下来n行，每行四个整数，第i行的数字: vi, ci,li ,ri ,（1<=vi<=10^4 , 1<=ci<=10^5,0<=li,ri<=10^5），车子们从1开始编号，从车队的最前头开始算起。', '　　第一行输出一个数k：会继续在这车队里的车的总数（注意我们的目标是让价值最大）。
　　第二行k个数，递增输出继续在车队里的车的编号。
　　请留心你不允许改变车的次序。如果答案不唯一，输出任意一个。', '[{"input": "5\n1 1 0 3\n10 1 2 1\n2 2 1 1\n10 1 1 2\n3 1 3 0", "output": "3\n1 3 5"}]', '2780aa61beadc03aa00a7fb5a4f0596d', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 6);INSERT INTO problem_tag(name) VALUES('dp,hash');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Don t fear, DravDe i' limit 1),(select id from problem_tag where name='dp,hash' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('2的次幂表示', '　　任何一个正整数都可以用2进制表示，例如：137的2进制表示为10001001。
　　将这种2进制表示写成2的次幂的和的形式，令次幂高的排在前面，可得到如下表达式：137=2^7+2^3+2^0
　　现在约定幂次用括号来表示，即a^b表示为a（b）
　　此时，137可表示为：2（7）+2（3）+2（0）
　　进一步：7=2^2+2+2^0  （2^1用2表示）
　　3=2+2^0 
　　所以最后137可表示为：2（2（2）+2+2（0））+2（2+2（0））+2（0）
　　又如：1315=2^10+2^8+2^5+2+1
　　所以1315最后可表示为：
　　2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）', '　　正整数（1<=n<=20000）', '　　符合约定的n的0，2表示（在表示中不能有空格）', '[{"input": "1315", "output": "2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)"}]', '41275ed680b794569ba396fcd9e1ba33', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('The Traveling Judges', '　　一组人要担任在一个特定城市举办的比赛的评委，他们需要找到最便宜的租车方式使得每个人都到达目标城市。他们观察发现，如果几个人在旅途的某一段坐同一辆租的车，就可以减少总费用。你的任务就是找出这些人应该采取的路线使得租车的总费用最小。
　　我们假定：
　　1. 租一辆车的费用与它行驶的距离成正比，没有燃油、保险、乘客人数多于一个等产生的额外费用。
　　2. 所有车的费用与行驶距离的比例相同。
　　3. 一辆车可以容纳任意数量的乘客。
　　4. 任意一对城市之间最多只有一条道路直接相连，每条道路都是双向的且长度大于0。
　　5. 每个人的起始城市到目标城市都至少有一种路线。
　　6. 若多个人的路线中经过同一城市，则这些人从该城市到目标城市必乘同一辆车。
　　7. 一个人可以乘一辆车到某个城市，再乘另一辆车离开该城市。', '　　第一行包含三个整数nc, dc和nr，表示地图上的城市个数，目标城市的编号和地图上的道路条数。
　　接下来nr行每行包含三个整数c1, c2和dist，表示一条长度为dist的双向道路(c1, c2)。
　　接下来一行包含一个整数nj，表示人数。
　　接下来一行包含nj个整数，表示每个人的起始城市。', '　　第一行包含“distance = ”和一个整数，表示所租的车行驶的最小总距离。
　　接下来nj行每行包含一个人的访问路线，城市按访问顺序给出并用“-”连接。
　　存在多种方案时，选择需要访问到的城市集合元素最少的一种；仍然存在多种方案时，选择集合元素升序排列后字典序最小的一种。', '[{"input": "3 3 3\n1 2 2\n1 3 3\n2 3 1\n2\n2 1", "output": "distance = 3\n2-3\n1-2-3"}]', '88c029f38eff4eb772d5cf4a296ac8a7', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 3);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('最小生成树');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='The Traveling Judges' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='The Traveling Judges' limit 1),(select id from problem_tag where name='最小生成树' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('奇偶判断', '　　能被2整除的数称为偶数，不能被2整除的数称为奇数。给一个整数x，判断x是奇数还是偶数。', '　　输入包括一个整数x，0<=x<=100000000。', '　　如果x是奇数，则输出“odd”，如果是偶数，则输出“even”。', '[{"input": "2009", "output": "odd"}]', 'ea3ea6e2fe3cd95b149a2f8b9004e0d5', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 1);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('大小写判断', '　　给定一个英文字母判断这个字母是大写还是小写。', '　　输入只包含一个英文字母c。', '　　如果c是大写字母，输出“upper”，否则输出“lower”。', '[{"input": "B", "output": "upper"}]', '7160d6e9a86b8132efb1e7d12c533c1a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 9);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Airport Configuration', '　　ACM机场是一个本地机场，对于大多数人来说，机场不是他们的终点或起点，而是中转站。机场有一个规划图。到达的大门在机场的北边（相当于空格）。出发的大门在机场的南边（也相当于空格）。两个正对着的大门距离相当于大门间的距离。每一个到达的大门只对应一个城市。每一个出发的大门也是这样。乘客到达的大门对应他们的起始城市，而出发大门对应他们的目标城市。因为这个问题，我们只需考虑转机的乘客。
　　转机的乘客会产生机场的交通堵塞。我们已经知道某两个城市之间的平均客流量。用这些信息，有可能能降低交通堵塞。例如，Cx城到Cy城的客流量大，就可以将他们安排得很近，甚至是对位。
　　因为花园和商店无法穿越，所以到达门G1和出发们G3（见图）的距离为1+2=3。
　　你需要计算几个方案的客流指数。两个大门间的客流指数等于人数乘以距离。而总的客流指数就是所有门之间的客流指数之和。



', '　　输入文件有多组测试数据。
　　最后一组只有一个0。
　　每组测试数据的输入有两部分。先是客流数据，之后是机场布局。
　　数据开始时一个n(1<n<25)，表示城市数。接下来n行，每行表示一个城市的数据，第i行先是一个整数，表示起始城市，再一个1到n的整数k，表示目标城市数，k对整数，每对描述一个目标城市，第一个数是城市编号j，然后是乘客数目(最多500)从i到j的人数。
　　机场布局部分包括1到20个方案。用一个0结束。
　　一个方案包括3行。第一行一个数表示编号，第二行是1-n的一个排列，描述到达门对应的城市的排列，第三行用同样的方式描述出发大门。', '　　对于每个测试数据，输出包括一个表格，表示方案编号和客流指数，按照客流指数升序输出。若客流指数相同，则编号小的排在前面。见样例。注意方案编号右对齐，而客流指数左对齐。（样例输出前面4个空格，后面9个空格，然后没有空格，详见未格式化的试题。', '[{"input": "3\n1  2  2 10  3 15\n2  1  3 10\n3  2  1 12  2 20\n1\n1 2 3\n2 3 1\n2\n2 3 1\n3 2 1\n0\n2\n1 1  2 100\n2  1  1 200\n1\n1 2\n1 2\n2\n1 2\n2 1\n0\n0", "output": "Configuration Load\n2         119\n1         122\nConfiguration Load\n2         300\n1         600"}]', '9cc2fda5ea4d88e69911b5aa7f20e202', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 5);INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Airport Configuration' limit 1),(select id from problem_tag where name='模拟' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('infiltration', '　　早上好，特工W-12，你需要完成的以下的任务。
　　我们已经渗透到一个叫混乱与祸害的组织中，希望能掌握该组织的管理权。不幸的是，它们似乎已经准备好应对这样的事件了，它们使用了一个很复杂的设计分配管理权力，这使得我们的渗透工作非常艰难。
　　那家组织的管理系统被分成若干个单位，对于任意两个单位A和B，要么A管理B要么B管理A，同时这个管理关系可以形成环，因此可以出现A管理B、B管理C、C管理A的情况。
　　我们可以安排特工去渗透到任意一个单位，那将使得我们控制该单位和那个单位直接管理的单位，但是不包括间接管理的单位。比如之前的样例，渗透到A单位会让我们控制A和B，但不能控制C。
　　对于一个成功的渗透工作来说，我们必须要控制所有的单位才行，否则其他单位会发现我们，同时破坏我们的计划。而你也知道，我们现在从更高的部门那里拿到的经费十分紧缺，我们必须最高效地完成任务。你的任务就是要找出控制单位最少的可行方案。', '　　第一行包含一个整数n，表示该组织的单位数。接下来n行每行n个二进制位。在其中的第i行第j列位置，若为1表示i单位控制j单位，否则j单位控制i单位。', '　　共一行，第一个整数ans表示最少的控制单位数量，接下来ans个整数表示任意一组可行的方案。', '[{"input": "样例1：\n2\n00\n10\n样例2：\n3\n010\n001\n100\n样例3：\n5\n01000\n00011\n11001\n10100\n10010", "output": "样例1：\n1 2\n样例2：\n2 1 2\n样例3：\n2 2 3"}]', '50b4615ed146685ef170512ec36b001a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Low', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 18);INSERT INTO problem_tag(name) VALUES('枚举');INSERT INTO problem_tag(name) VALUES('图论');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='infiltration' limit 1),(select id from problem_tag where name='枚举' limit 1));INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='infiltration' limit 1),(select id from problem_tag where name='图论' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('关联矩阵', '　　有一个n个结点m条边的有向图，请输出他的关联矩阵。', '　　第一行两个整数n、m，表示图中结点和边的数目。n<=100,m<=1000。
　　接下来m行，每行两个整数a、b，表示图中有(a,b)边。
　　注意图中可能含有重边，但不会有自环。', '　　输出该图的关联矩阵，注意请勿改变边和结点的顺序。', '[{"input": "5 9\n1 2\n3 1\n1 5\n2 5\n2 3\n2 3\n3 2\n4 3\n5 4", "output": "1 -1 1 0 0 0 0 0 0\n-1 0 0 1 1 1 -1 0 0\n0 1 0 0 -1 -1 1 -1 0\n0 0 0 0 0 0 0 1 -1\n0 0 -1 -1 0 0 0 0 1"}]', '11f6fe71e9d7f09cb1ae41274d588325', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 2);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('一元三次方程', '　　有形如：ax3+bx2+cx+d=0  这样的一个一元三次方程。给出该方程中各项的系数(a，b，c，d  均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值>=1。要求三个实根。。', '　　四个实数：a，b，c，d', '　　由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位', '[{"input": "1   -5   -4   20", "output": "-2.00          2.00   5.00"}]', '1d4116adaea1c05e949f8980ca7ed39a', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 4);INSERT INTO problem_tag(name) VALUES('解方程');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='一元三次方程' limit 1),(select id from problem_tag where name='解方程' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('乘法表', '　　输出九九乘法表。', '', '　　输出格式见下面的样例。乘号用“*”表示。', '[]', 'dbac10769d0ade0030680f67b2db95dc', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 7);
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('结点选择', '
有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？
', '
第一行包含一个整数 n 。
接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。
接下来一共 n-1 行，每行描述树上的一条边。
', '
	输出一个整数，代表选出的点的权值和的最大值。
', '[{"input": "\n5\n1 2 3 4 5\n1 2\n1 3\n2 4\n2 5\n", "output": "\n12\n\t"}]', '2d874a6c2c84c019c870d411dd39740c', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 11);INSERT INTO problem_tag(name) VALUES('树形动态规划');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='结点选择' limit 1),(select id from problem_tag where name='树形动态规划' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('阶乘末尾', '　　给定n和len，输出n!末尾len位。', '　　一行两个正整数n和len。', '　　一行一个字符串，表示答案。长度不足用前置零补全。', '[{"input": "6 5", "output": "00720"}]', '3c31dc448459533aad9640d2d438fb27', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'High', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 8);INSERT INTO problem_tag(name) VALUES('循环');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='阶乘末尾' limit 1),(select id from problem_tag where name='循环' limit 1));
INSERT INTO problem (title, description, input_description, output_description, samples, test_case_id, test_case_score, languages, template, time_limit, memory_limit, spj, rule_type, visible, difficulty, submission_number, accepted_number, created_by_id, statistic_info, total_score, is_public, spj_compile_ok, create_time, is_open_test_case, is_valid, vote_rank_score, _id) VALUES ('Entertaining Geodeti', '　　在此游戏中地图被分为了许多叫作Geo格的正方形方格，其中一些被涂上色，假设没有涂色的为透明色。
　　地图中还有些Geo符号，它们样子像不同颜色的金字塔（包括透明Geo符号）。每个Geo符号都坐落在Geo格上，每个Geo格上最多一个Geo符号。
　　Geo符号可以被消除。为了更好地理解Geo符号在消除时发生了什么，这里引入把刚消除的Geo符号放入的队列。
　　从队列中取出Geo符号，观察包含Geo符号的Geo格的颜色，如果它不是透明的且颜色不同于Geo符号，则把所有这个颜色的Geo格重新涂为Geo符号的颜色（透明的Geo符号则为透明色）。重涂色是在一个无限大的区域从那个有符号的Geo格子开始螺旋状进行的。
　　.
　　换句话说，我们选择所有需要重涂色的方格找到它们在以有符号格为中心的无限螺旋表格中所对应的数字。此后按数字的增加顺序我们对其重染色。
　　如果在重染色时遇到一个格子包含另一个Geo符号的情况则将Geo符号移出并放置在队列尾部。
　　当重染色结束后Geo符号彻底消失，并且队列中下一个Geo符号（如果有）将取出，重复此操作直至队列为空。
　　为了更好地理解请看一个例子。
　　你知道所有格子的颜色、所有符号的位置。计算出队列里符号彻底消失时所造成的重染色次数。
　　推荐使用I64d输出。', '　　第一行包含两个数n，m(1<=n，m<=300)—地图的高和宽。
　　接下来n行每行m个数—格子的颜色。
　　接下来n行每行m个数—对符号的描述，-1表示没有符号，否则数字代表符号的颜色。
　　所有颜色都是属于0到10^9的整数，0表示透明。
　　最后一行两个数x，y(1<=x<=n，1<=y<=m)—需要消除的Geo符号的行和列位置。行从上到下标记，列从左往右标记，从1开始。保证位置(x，y)包含一个符号。', '　　一行一个数—符号消除时重染色次数。', '[{"input": "5 5\n9 0 1 1 0\n0 0 3 2 0\n1 1 1 3 0\n1 1 1 3 0\n0 1 2 0 3\n-1 1 -1 3 -1\n-1 -1 -1 0 -1\n-1 -1 -1 -1 -1\n-1 2 3 -1 -1\n-1 -1 -1 -1 2\n4 2", "output": "35"}]', '3a72b0321bffdeab82a305eab21b1015', '[]', '["C", "C++", "Java", "Python2", "Python3"]', '{}', 1000, 128, false, 'ACM', true, 'Mid', 0, 0, 2729, '{}', 0, false, false, now(), true, true, 0, 1);INSERT INTO problem_tag(name) VALUES('模拟');INSERT INTO problem_tags(problem_id,problemtag_id) VALUES((SELECT id FROM problem where title='Entertaining Geodeti' limit 1),(select id from problem_tag where name='模拟' limit 1));
